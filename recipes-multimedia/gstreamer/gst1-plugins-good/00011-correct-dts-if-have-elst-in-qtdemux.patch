From 8a7dd63fc0907150a427b84bb4d8b36857b8a6b1 Mon Sep 17 00:00:00 2001
From: "sheng.liu" <sheng.liu@amlogic.com>
Date: Sat, 9 Oct 2021 12:17:49 +0800
Subject: [PATCH] gstreamer1.0-plugins-good: correct dts if have elst in
 qtdemux [1/1]

PD#SWPL-60613

Problem:
there is elst atom which lead the pts start from non-zero

Solution:
adjust dts refer to elst

Verify:
AP222

Change-Id: Ie27d90eee01dc13a203a0e6bcaf8bdaa30f34097
---
 gst/isomp4/qtdemux.c | 38 +++++++++++++++++++++++++++++++++-----
 1 file changed, 33 insertions(+), 5 deletions(-)

diff --git a/gst/isomp4/qtdemux.c b/gst/isomp4/qtdemux.c
index c6724aa..a795dc2 100644
--- a/gst/isomp4/qtdemux.c
+++ b/gst/isomp4/qtdemux.c
@@ -453,6 +453,8 @@ struct _QtDemuxStream
   GQueue protection_scheme_event_queue;
 
   gint ref_count;               /* atomic */
+
+  guint64 min_corrected_dts;
 };
 
 /* Contains properties and cryptographic info for a set of samples from a
@@ -5280,7 +5282,14 @@ gst_qtdemux_prepare_current_sample (GstQTDemux * qtdemux,
   *pts = QTSAMPLE_PTS (stream, sample);
   *offset = sample->offset;
   *size = sample->size;
-  *duration = QTSAMPLE_DUR_DTS (stream, sample, *dts);
+  if (GST_CLOCK_TIME_IS_VALID (*dts))
+  {
+    *duration = QTSAMPLE_DUR_DTS (stream, sample, *dts);
+  }
+  else
+  {
+    *duration = QTSTREAMTIME_TO_GSTTIME(stream, sample->duration);
+  }
   *keyframe = QTSAMPLE_KEYFRAME (stream, sample);
 
   return TRUE;
@@ -9550,13 +9559,21 @@ done2:
       stts_time = stream->stts_time;
 
       for (j = stream->stts_sample_index; j < stts_samples; j++) {
+
+        if ((stream->subtype == FOURCC_vide)
+         && (stream->min_corrected_dts != G_MAXUINT64))
+        {
+          cur->timestamp = stts_time - stream->min_corrected_dts;
+        }
+        else
+        {
+          cur->timestamp = stts_time;
+        }
+        cur->duration = stts_duration;
         GST_DEBUG_OBJECT (qtdemux,
             "sample %d: index %d, timestamp %" GST_TIME_FORMAT,
             (guint) (cur - samples), j,
-            GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream, stts_time)));
-
-        cur->timestamp = stts_time;
-        cur->duration = stts_duration;
+            GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream, cur->timestamp)));
 
         /* avoid 32-bit wrap-around,
          * but still mind possible 'negative' duration */
@@ -9685,6 +9702,13 @@ ctts:
 
       for (j = stream->ctts_sample_index; j < ctts_count; j++) {
         cur->pts_offset = ctts_soffset;
+        if (!GST_CLOCK_TIME_IS_VALID(QTSAMPLE_PTS(stream, cur)))
+        {
+          cur->timestamp = cur->timestamp + stream->min_corrected_dts;
+          stream->min_corrected_dts = MIN(cur->timestamp + stream->cslg_shift + cur->pts_offset, stream->min_corrected_dts);
+          cur->timestamp = cur->timestamp - stream->min_corrected_dts;
+          GST_DEBUG_OBJECT (qtdemux, "pts is invalid, adjust min_corrected_dts: %lld, new dts: %lld",stream->min_corrected_dts, cur->timestamp);
+        }
         cur++;
 
         if (G_UNLIKELY (cur > last)) {
@@ -9761,6 +9785,7 @@ qtdemux_parse_segments (GstQTDemux * qtdemux, QtDemuxStream * stream,
   GST_DEBUG_OBJECT (qtdemux, "looking for edit list container");
   stream->n_segments = 0;
   stream->segments = NULL;
+  stream->min_corrected_dts = G_MAXUINT64;
   if ((edts = qtdemux_tree_get_child_by_type (trak, FOURCC_edts))) {
     GNode *elst;
     gint n_segments;
@@ -9821,7 +9846,10 @@ qtdemux_parse_segments (GstQTDemux * qtdemux, QtDemuxStream * stream,
       }
 
       if (!empty_edit)
+      {
+        stream->min_corrected_dts = MIN(media_time, stream->min_corrected_dts);
         media_start = QTSTREAMTIME_TO_GSTTIME (stream, media_time);
+      }
 
       segment = &stream->segments[segment_number];
 
-- 
2.32.0

