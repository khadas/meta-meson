From 7a1638a8fe4b4f2744db213ca9a5c5e1fa0ecd2b Mon Sep 17 00:00:00 2001
From: "gaojie.song" <gaojie.song@amlogic.com>
Date: Tue, 28 Nov 2023 10:11:30 +0800
Subject: [PATCH 1/1] fix cbc1 audio decrypt

---
 gst/isomp4/fourcc.h        |   1 +
 gst/isomp4/qtdemux.c       | 210 +++++++++++++++++++++++++++++--------
 gst/isomp4/qtdemux_types.c |   1 +
 3 files changed, 167 insertions(+), 45 deletions(-)
 mode change 100755 => 100644 gst/isomp4/fourcc.h
 mode change 100755 => 100644 gst/isomp4/qtdemux.c

diff --git a/gst/isomp4/fourcc.h b/gst/isomp4/fourcc.h
old mode 100755
new mode 100644
index 8e8a1bb..bf7ab0a
--- a/gst/isomp4/fourcc.h
+++ b/gst/isomp4/fourcc.h
@@ -394,6 +394,7 @@ G_BEGIN_DECLS
 #define FOURCC_frma     GST_MAKE_FOURCC('f','r','m','a')
 #define FOURCC_schm     GST_MAKE_FOURCC('s','c','h','m')
 #define FOURCC_schi     GST_MAKE_FOURCC('s','c','h','i')
+#define FOURCC_senc     GST_MAKE_FOURCC('s','e','n','c')
 
 /* Common Encryption */
 #define FOURCC_pssh     GST_MAKE_FOURCC('p','s','s','h')
diff --git a/gst/isomp4/qtdemux.c b/gst/isomp4/qtdemux.c
old mode 100755
new mode 100644
index a9d106f..239f5be
--- a/gst/isomp4/qtdemux.c
+++ b/gst/isomp4/qtdemux.c
@@ -2872,7 +2872,8 @@ qtdemux_update_default_sample_encryption_settings (GstQTDemux * qtdemux,
       "skip_byte_block", G_TYPE_UINT, skip_byte_block,
       NULL);
   GST_DEBUG_OBJECT (qtdemux, "default sample properties: "
-      "is_encrypted=%u, iv_size=%u constant_iv_size=%u", is_encrypted, iv_size, constant_iv_size);
+      "is_encrypted=%u, iv_size=%u constant_iv_size=%u %u %u",
+      is_encrypted, iv_size, constant_iv_size, crypt_byte_block, skip_byte_block);
   if (constant_iv != NULL) {
     GstBuffer *constant_iv_buf =
         gst_buffer_new_allocate (NULL, constant_iv_size, NULL);
@@ -4000,6 +4001,7 @@ qtdemux_parse_cenc_aux_info (GstQTDemux * qtdemux, QtDemuxStream * stream,
       return FALSE;
     }
     if (iv_size > 0) {
+      GST_DEBUG_OBJECT (qtdemux, "iv_size %u", iv_size);
       if (!gst_byte_reader_dup_data (br, iv_size, &data)) {
         GST_ERROR_OBJECT (qtdemux, "failed to get IV for sample %u", i);
         gst_structure_free (properties);
@@ -4119,6 +4121,147 @@ qtdemux_parse_pssh (GstQTDemux * qtdemux, GNode * node)
   return TRUE;
 }
 
+static void
+qtdemux_parse_senc (GstQTDemux * qtdemux, QtDemuxStream * stream, GstByteReader * br)
+{
+  guint8 version = 0;
+  guint32 flags = 0;
+  gboolean use_subsample_encryption = FALSE;
+  guint16 subsample_count = 0;
+  guint32 byte_of_clear_data = 0;
+  guint32 byte_of_protected_data = 0;
+  guint32 sample_count = 0;
+  gint i, j;
+  guint iv_size = 8;
+  QtDemuxCencSampleSetInfo *ss_info = NULL;
+
+  if (!stream->protection_scheme_info)
+    stream->protection_scheme_info = g_new0 (QtDemuxCencSampleSetInfo, 1);
+
+  ss_info = (QtDemuxCencSampleSetInfo *) stream->protection_scheme_info;
+  if (!ss_info->default_properties) {
+    ss_info->default_properties =
+        gst_structure_new ("application/x-cenc",
+        "encrypted", G_TYPE_BOOLEAN, TRUE,
+        NULL);
+  }
+
+  if (ss_info->crypto_info) {
+    GST_LOG_OBJECT (qtdemux, "unreffing existing crypto_info");
+    g_ptr_array_free (ss_info->crypto_info, TRUE);
+    ss_info->crypto_info = NULL;
+  }
+
+  if (!gst_byte_reader_get_uint8 (br, &version)) {
+    GST_ERROR_OBJECT (qtdemux, "Error getting box's version field");
+    return;
+  }
+
+  GST_DEBUG_OBJECT (qtdemux, "version %d", version);
+
+  if (version > 0) {
+    return;
+  }
+
+  if (!gst_byte_reader_get_uint24_be (br, &flags)) {
+    GST_ERROR_OBJECT (qtdemux, "Error getting box's flags field");
+    return;
+  }
+
+  if (flags & 0x000002) {
+    use_subsample_encryption = TRUE;
+  }
+
+  if (!gst_structure_get_uint (ss_info->default_properties, "iv_size", &iv_size)) {
+    GST_ERROR_OBJECT (qtdemux, "Error getting encryption IV size field");
+    return;
+  }
+  GST_DEBUG_OBJECT (qtdemux, "iv_size %d", iv_size);
+
+  if (!gst_byte_reader_get_uint32_be (br, &sample_count)) {
+    GST_ERROR_OBJECT (qtdemux, "Error getting box's sample count field");
+    return;
+  }
+
+  ss_info->crypto_info =
+      g_ptr_array_new_full (sample_count,
+      (GDestroyNotify) qtdemux_gst_structure_free);
+
+  for (i = 0; i < sample_count; i++) {
+    GstStructure *properties;
+    guint8 *data;
+    GstBuffer *buf;
+    GstBuffer *subsamples = NULL;
+
+    properties = qtdemux_get_cenc_sample_properties (qtdemux, stream, i);
+    if (properties == NULL) {
+      GST_ERROR_OBJECT (qtdemux, "failed to get properties for sample %u", i);
+      qtdemux->cenc_aux_sample_count = i;
+      return;
+    }
+
+    if (iv_size > 0) {
+      if (!gst_byte_reader_dup_data (br, iv_size, &data)) {
+        GST_ERROR_OBJECT (qtdemux, "IV data not present for sample %u", i);
+        gst_structure_free (properties);
+        qtdemux->cenc_aux_sample_count = i;
+        return;
+      }
+      buf = gst_buffer_new_wrapped (data, iv_size);
+      gst_structure_set (properties, "iv", GST_TYPE_BUFFER, buf, NULL);
+      gst_buffer_unref (buf);
+    } else {
+      const GValue *constant_iv_size_value =
+          gst_structure_get_value (properties, "constant_iv_size");
+      const GValue *constant_iv_value =
+          gst_structure_get_value (properties, "iv");
+      if (constant_iv_size_value == NULL || constant_iv_value == NULL) {
+        GST_ERROR_OBJECT (qtdemux, "failed to get constant_iv");
+        gst_structure_free (properties);
+        return;
+      }
+      gst_structure_set_value (properties, "iv_size", constant_iv_size_value);
+    }
+
+    if (use_subsample_encryption) {
+      const GValue *kid_buf_value;
+      if (!gst_byte_reader_get_uint16_be (br, &subsample_count)
+        || subsample_count == 0) {
+        GST_ERROR_OBJECT (qtdemux,
+            "failed to get subsample count for sample %u", i);
+        gst_structure_free (properties);
+        qtdemux->cenc_aux_sample_count = i;
+        return;
+      }
+      GST_DEBUG_OBJECT (qtdemux, "subsample_count %d", subsample_count);
+
+      if (!gst_byte_reader_dup_data (br, subsample_count * 6, &data)) {
+        GST_ERROR_OBJECT (qtdemux, "failed to get subsample data for sample %u",
+            i);
+        gst_structure_free (properties);
+        qtdemux->cenc_aux_sample_count = i;
+        return;
+      }
+      buf = gst_buffer_new_wrapped (data, subsample_count * 6);// guint16 clr + guint32 enc
+      kid_buf_value = gst_structure_get_value (ss_info->default_properties, "kid");
+
+      gst_structure_set (properties,
+          "subsample_count", G_TYPE_UINT, subsample_count,
+          "subsamples", GST_TYPE_BUFFER, buf, NULL);
+      gst_structure_set_value (properties, "kid", kid_buf_value);
+      gst_buffer_unref (buf);
+    } else {
+      gst_structure_set (properties,
+          "subsample_count", G_TYPE_UINT, 0,
+          "subsamples", GST_TYPE_BUFFER, NULL, NULL);
+    }
+
+    g_ptr_array_add (ss_info->crypto_info, properties);
+  }
+
+  qtdemux->cenc_aux_sample_count = sample_count;
+}
+
 static gboolean
 qtdemux_parse_moof (GstQTDemux * qtdemux, const guint8 * buffer, guint length,
     guint64 moof_offset, QtDemuxStream * stream)
@@ -4128,6 +4271,8 @@ qtdemux_parse_moof (GstQTDemux * qtdemux, const guint8 * buffer, guint length,
   GstByteReader mfhd_data, trun_data, tfhd_data, tfdt_data;
   GNode *saiz_node, *saio_node, *pssh_node;
   GstByteReader saiz_data, saio_data;
+  GNode *senc_node;
+  GstByteReader senc_data;
   guint32 ds_size = 0, ds_duration = 0, ds_flags = 0;
   gint64 base_offset, running_offset;
   guint32 frag_num;
@@ -4225,6 +4370,15 @@ qtdemux_parse_moof (GstQTDemux * qtdemux, const guint8 * buffer, guint length,
       }
     } else {
       GST_WARNING_OBJECT (qtdemux, "no saiz_node, may cbc1 audio");
+      senc_node =
+          qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_senc,
+          &senc_data);
+      if (senc_node) {
+        GST_DEBUG_OBJECT (qtdemux, "parsing senc box");
+        qtdemux_parse_senc (qtdemux, stream, &senc_data);
+      } else {
+        GST_WARNING_OBJECT (qtdemux, "no senc_node");
+      }
     }
 
     tfdt_node =
@@ -5912,7 +6066,7 @@ gst_qtdemux_push_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,
   if (stream->protected && (stream->protection_scheme_type == FOURCC_cenc
       || stream->protection_scheme_type == FOURCC_cbcs
       || stream->protection_scheme_type == FOURCC_cens)) {
-    GstStructure *crypto_info;
+    GstStructure *crypto_info = NULL;
     QtDemuxCencSampleSetInfo *info =
         (QtDemuxCencSampleSetInfo *) stream->protection_scheme_info;
     gint index;
@@ -5926,49 +6080,8 @@ gst_qtdemux_push_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,
     }
 
     if (info->crypto_info == NULL) {
-      /* cbc1 audio may has no saiz node, need update crypto info from default properties */
-      if (stream->protection_scheme_type == FOURCC_cbcs) {
-        guint crypt_byte_block = 0;
-        guint skip_byte_block = 0;
-        guint iv_size = 0;
-        guint constant_iv_size = 0;
-
-        crypto_info = qtdemux_get_cenc_sample_properties (qtdemux, stream, 0);
-        gst_structure_get (crypto_info,
-            "crypt_byte_block", G_TYPE_UINT, &crypt_byte_block,
-            "skip_byte_block", G_TYPE_UINT, &skip_byte_block,
-            "iv_size", G_TYPE_UINT, &iv_size,
-            NULL);
-        if (iv_size == 0) {
-          if (!gst_structure_get_uint (crypto_info, "constant_iv_size", &constant_iv_size)) {
-            GST_ERROR_OBJECT (qtdemux, "failed to get iv_size");
-          } else {
-            gst_structure_set (crypto_info, "iv_size", G_TYPE_UINT, constant_iv_size, NULL);
-          }
-        }
-
-        meta = gst_buffer_get_protection_meta(buf);
-        if (meta) {
-          GST_DEBUG_OBJECT (qtdemux, "protection metadata name %s", gst_structure_get_name(meta->info));
-          gst_structure_set (meta->info,
-              "crypt_byte_block", G_TYPE_UINT, crypt_byte_block,
-              "skip_byte_block", G_TYPE_UINT, skip_byte_block,
-              NULL);
-        } else {
-          GST_INFO_OBJECT (qtdemux, "no cbcs protection metadata");
-        }
-
-        if (!meta && (!crypto_info || !gst_buffer_add_protection_meta (buf, crypto_info))) {
-          GST_ERROR_OBJECT (qtdemux,
-              "failed to attach cbcs metadata to buffer");
-          qtdemux_gst_structure_free (crypto_info);
-        } else {
-          GST_TRACE_OBJECT (qtdemux, "added cbcs protection metadata");
-        }
-      } else {
-        GST_DEBUG_OBJECT (qtdemux,
-            "cenc metadata hasn't been parsed yet, pushing buffer as if it wasn't encrypted");
-      }
+      GST_DEBUG_OBJECT (qtdemux,
+          "cenc metadata hasn't been parsed yet, pushing buffer as if it wasn't encrypted");
     } else {
       /* The end of the crypto_info array matches our n_samples position,
        * so count backward from there */
@@ -5992,6 +6105,13 @@ gst_qtdemux_push_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,
               "crypt_byte_block", G_TYPE_UINT, &crypt_byte_block,
               "skip_byte_block", G_TYPE_UINT, &skip_byte_block,
               NULL);
+          if (crypt_byte_block == 0 && skip_byte_block == 0
+              && (0 == strncmp(GST_PAD_NAME (stream->pad), "audio", 5))) {
+            crypt_byte_block = 1;
+            gst_structure_set (crypto_info,
+                "crypt_byte_block", G_TYPE_UINT, crypt_byte_block,
+                NULL);
+          }
           meta = gst_buffer_get_protection_meta(buf);
           if (meta) {
             GST_DEBUG_OBJECT (qtdemux, "protection metadata name %s", gst_structure_get_name(meta->info));
diff --git a/gst/isomp4/qtdemux_types.c b/gst/isomp4/qtdemux_types.c
index d153dbf..08c1daa 100644
--- a/gst/isomp4/qtdemux_types.c
+++ b/gst/isomp4/qtdemux_types.c
@@ -229,6 +229,7 @@ static const QtNodeType qt_node_types[] = {
   {FOURCC_dvcC, "DOVI in dvcC box", 0},
   {FOURCC_dvvC, "DOVI in dvvC box", 0},
   {FOURCC_dvwC, "DOVI in dvwC box", 0},
+  {FOURCC_senc, "sample encryption box", 0},
   {0, "unknown", 0,},
 };
 
-- 
2.33.0

