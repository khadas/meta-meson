Index: gst-plugins-base-1.16.3/gst-libs/gst/video/Makefile.am
===================================================================
--- gst-plugins-base-1.16.3.orig/gst-libs/gst/video/Makefile.am
+++ gst-plugins-base-1.16.3/gst-libs/gst/video/Makefile.am
@@ -5,7 +5,7 @@ include $(top_srcdir)/common/orc.mak
 glib_enum_headers = video.h video-format.h video-color.h video-info.h video-dither.h \
 			colorbalance.h navigation.h video-chroma.h video-tile.h video-converter.h \
 			video-resampler.h video-frame.h video-scaler.h video-anc.h \
-			video-overlay-composition.h
+			video-overlay-composition.h video-hdr.h
 glib_enum_define = GST_VIDEO
 glib_gen_prefix = gst_video
 glib_gen_basename = video
@@ -54,6 +54,7 @@ libgstvideo_@GST_API_VERSION@_la_SOURCES
 	video-blend.c		\
 	video-overlay-composition.c \
 	video-multiview.c	\
+	video-hdr.c             \
 	gstvideotimecode.c
 
 nodist_libgstvideo_@GST_API_VERSION@_la_SOURCES = $(BUILT_SOURCES)
@@ -92,6 +93,7 @@ libgstvideo_@GST_API_VERSION@include_HEA
 	video-blend.h		\
 	video-overlay-composition.h \
 	video-multiview.h	\
+	video-hdr.h             \
 	gstvideotimecode.h
 
 nodist_libgstvideo_@GST_API_VERSION@include_HEADERS = $(built_headers)
Index: gst-plugins-base-1.16.3/gst-libs/gst/video/video-color.c
===================================================================
--- gst-plugins-base-1.16.3.orig/gst-libs/gst/video/video-color.c
+++ gst-plugins-base-1.16.3/gst-libs/gst/video/video-color.c
@@ -381,6 +381,7 @@ gst_video_color_matrix_get_Kr_Kb (GstVid
       *Kb = 0.087;
       break;
     case GST_VIDEO_COLOR_MATRIX_BT2020:
+    case GST_VIDEO_COLOR_MATRIX_BT2020_CL:
       *Kr = 0.2627;
       *Kb = 0.0593;
       break;
@@ -432,6 +433,7 @@ gst_video_color_transfer_encode (GstVide
       res = pow (val, 1.0 / 2.2);
       break;
     case GST_VIDEO_TRANSFER_BT709:
+    case GST_VIDEO_TRANSFER_BT2020_10:
       if (val < 0.018)
         res = 4.5 * val;
       else
@@ -470,6 +472,16 @@ gst_video_color_transfer_encode (GstVide
       else
         res = 1.0993 * pow (val, 0.45) - 0.0993;
       break;
+    case GST_VIDEO_TRANSFER_SMPTE_ST_2084:
+        /* TODO: add the code to correctly return the transfer value */
+        res = val;
+      break;
+    case GST_VIDEO_TRANSFER_ARIB_STD_B67:
+      if (val <= 1)
+        res = 0.5 * sqrt(val);
+      else
+        res = 0.17883277 * log(val - 0.28466892) + 0.55991073;
+      break;
     case GST_VIDEO_TRANSFER_ADOBERGB:
       res = pow (val, 1.0 / 2.19921875);
       break;
@@ -520,6 +532,7 @@ gst_video_color_transfer_decode (GstVide
       res = pow (val, 2.2);
       break;
     case GST_VIDEO_TRANSFER_BT709:
+    case GST_VIDEO_TRANSFER_BT2020_10:
       if (val < 0.081)
         res = val / 4.5;
       else
@@ -558,6 +571,16 @@ gst_video_color_transfer_decode (GstVide
       else
         res = pow ((val + 0.0993) / 1.0993, 1.0 / 0.45);
       break;
+    case GST_VIDEO_TRANSFER_SMPTE_ST_2084:
+        /* TODO: add the code to correctly return the transfer value */
+        res = val;
+      break;
+    case GST_VIDEO_TRANSFER_ARIB_STD_B67:
+      if (val <= 0.5)
+        res = pow(val / 0.5, 2) ;
+      else
+        res = exp((val - 0.55991073)/0.17883277) + 0.28466892;
+      break;
     case GST_VIDEO_TRANSFER_ADOBERGB:
       res = pow (val, 2.19921875);
       break;
Index: gst-plugins-base-1.16.3/gst-libs/gst/video/video-color.h
===================================================================
--- gst-plugins-base-1.16.3.orig/gst-libs/gst/video/video-color.h
+++ gst-plugins-base-1.16.3/gst-libs/gst/video/video-color.h
@@ -62,7 +62,8 @@ typedef enum {
   GST_VIDEO_COLOR_MATRIX_BT709,
   GST_VIDEO_COLOR_MATRIX_BT601,
   GST_VIDEO_COLOR_MATRIX_SMPTE240M,
-  GST_VIDEO_COLOR_MATRIX_BT2020
+  GST_VIDEO_COLOR_MATRIX_BT2020,
+  GST_VIDEO_COLOR_MATRIX_BT2020_CL
 } GstVideoColorMatrix;
 
 GST_VIDEO_API
@@ -106,7 +107,10 @@ typedef enum {
   GST_VIDEO_TRANSFER_GAMMA28,
   GST_VIDEO_TRANSFER_LOG100,
   GST_VIDEO_TRANSFER_LOG316,
+  GST_VIDEO_TRANSFER_BT2020_10,
   GST_VIDEO_TRANSFER_BT2020_12,
+  GST_VIDEO_TRANSFER_SMPTE_ST_2084,
+  GST_VIDEO_TRANSFER_ARIB_STD_B67,
   GST_VIDEO_TRANSFER_ADOBERGB
 } GstVideoTransferFunction;
 
Index: gst-plugins-base-1.16.3/gst-libs/gst/video/video-hdr.c
===================================================================
--- /dev/null
+++ gst-plugins-base-1.16.3/gst-libs/gst/video/video-hdr.c
@@ -0,0 +1,215 @@
+/* GStreamer
+ * Copyright (C) <2018> Seungha Yang <seungha.yang@navercorp.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include <string.h>
+#include <stdio.h>
+
+#include "video-hdr.h"
+
+/**
+ * gst_video_mastering_display_metadata_init:
+ * @minfo: a #GstVideoMasteringDisplayMetadata
+ *
+ * Initialize @minfo
+ */
+void
+gst_video_mastering_display_metadata_init (GstVideoMasteringDisplayMetadata *
+    minfo)
+{
+  g_return_if_fail (minfo != NULL);
+
+  memset (minfo, 0, sizeof (GstVideoMasteringDisplayMetadata));
+}
+
+/**
+ * gst_video_mastering_display_metadata_to_caps_string:
+ * @minfo: a #GstVideoMasteringDisplayMetadata
+ * Convert @minfo to its string representation.
+ *
+ * Returns: (transfer full): a pointer to string for
+ * mastering-display-metadata caps field
+ */
+gchar *
+gst_video_mastering_display_metadata_to_caps_string (const
+    GstVideoMasteringDisplayMetadata * minfo)
+{
+  g_return_val_if_fail (minfo != NULL, NULL);
+
+  return g_strdup_printf ("%lf:%lf:%lf:%lf:%lf:%lf:%lf:%lf:%lf:%lf",
+      minfo->Rx, minfo->Ry, minfo->Gx, minfo->Gy, minfo->Bx, minfo->By,
+      minfo->Wx, minfo->Wy, minfo->max_luma, minfo->min_luma);
+}
+
+/**
+ * gst_video_mastering_display_metadata_from_caps_string:
+ * @minfo: a #GstVideoMasteringDisplayMetadata
+ * @mastering: mastering-display-metadata field string from caps
+ *
+ * Parse the value of mastering-display-meta caps field and update @minfo
+ * with the parsed values.
+ *
+ * Returns: %TRUE if @mastering could be parsed
+ */
+gboolean
+    gst_video_mastering_display_metadata_from_caps_string
+    (GstVideoMasteringDisplayMetadata * minfo, const gchar * mastering) {
+  gdouble Rx, Ry;
+  gdouble Gx, Gy;
+  gdouble Bx, By;
+  gdouble Wx, Wy;
+  gdouble max_luma, min_luma;
+
+  g_return_val_if_fail (mastering != NULL, FALSE);
+
+  if (sscanf (mastering, "%lf:%lf:%lf:%lf:%lf:%lf:%lf:%lf:%lf:%lf",
+          &Rx, &Ry, &Gx, &Gy, &Bx, &By, &Wx, &Wy, &max_luma, &min_luma) == 10) {
+    minfo->Rx = Rx;
+    minfo->Ry = Ry;
+    minfo->Gx = Gx;
+    minfo->Gy = Gy;
+    minfo->Bx = Bx;
+    minfo->By = By;
+    minfo->Wx = Wx;
+    minfo->Wy = Wy;
+    minfo->max_luma = max_luma;
+    minfo->min_luma = min_luma;
+    return TRUE;
+  }
+
+  return FALSE;
+}
+
+/**
+ * gst_video_mastering_display_metadata_has_primaries:
+ * @minfo: a #GstVideoMasteringDisplayMetadata
+ *
+ * Validate primaries and white point values
+ *
+ * Returns: %TRUE if @minfo has valid primaries and white point values.
+ */
+gboolean
+gst_video_mastering_display_metadata_has_primaries (const
+    GstVideoMasteringDisplayMetadata * minfo)
+{
+  g_return_val_if_fail (minfo != NULL, FALSE);
+
+  return (minfo->Rx > 0 && minfo->Ry > 0 && minfo->Gx > 0 && minfo->Gy > 0 &&
+      minfo->Bx > 0 && minfo->By > 0 && minfo->Wx > 0 && minfo->Wy > 0);
+}
+
+/**
+ * gst_video_mastering_display_metadata_has_luminance:
+ * @minfo: a #GstVideoMasteringDisplayMetadata
+ *
+ * Validate display mastering luminance
+ *
+ * Returns: %TRUE if @minfo has valid display mastering luminance.
+ */
+gboolean
+gst_video_mastering_display_metadata_has_luminance (const
+    GstVideoMasteringDisplayMetadata * minfo)
+{
+  g_return_val_if_fail (minfo != NULL, FALSE);
+
+  return (minfo->max_luma > 0);
+}
+
+/**
+ * gst_video_mastering_display_metadata_is_equal:
+ * @minfo: a #GstVideoMasteringDisplayMetadata
+ * @other: a #GstVideoMasteringDisplayMetadata
+ *
+ * Checks equality between @minfo and @other.
+ *
+ * Returns: %TRUE if @minfo and @other are equal.
+ */
+gboolean
+gst_video_mastering_display_metadata_is_equal (const
+    GstVideoMasteringDisplayMetadata * minfo,
+    const GstVideoMasteringDisplayMetadata * other)
+{
+  g_return_val_if_fail (minfo != NULL, FALSE);
+  g_return_val_if_fail (other != NULL, FALSE);
+
+  return !memcmp (minfo, other, sizeof (GstVideoMasteringDisplayMetadata));
+}
+
+/**
+ * gst_video_content_light_level_init:
+ * @linfo: a #GstVideoContentLightLevel
+ *
+ * Initialize @linfo
+ */
+void
+gst_video_content_light_level_init (GstVideoContentLightLevel * linfo)
+{
+  g_return_if_fail (linfo != NULL);
+
+  memset (linfo, 0, sizeof (GstVideoContentLightLevel));
+}
+
+/**
+ * gst_video_content_light_level_to_caps_string:
+ * @linfo: a #GstVideoContentLightLevel
+ * Convert @linfo to its string representation.
+ *
+ * Returns: (transfer full): a pointer to string for
+ * content-light-level caps field
+ */
+gchar *
+gst_video_content_light_level_to_caps_string (const GstVideoContentLightLevel *
+    linfo)
+{
+  g_return_val_if_fail (linfo != NULL, NULL);
+
+  return g_strdup_printf ("%u:%u", linfo->maxCLL, linfo->maxFALL);
+}
+
+/**
+ * gst_video_content_light_level_from_caps_string:
+ * @linfo: a #GstVideoContentLightLevel
+ * @level: a content-light-level string from caps
+ *
+ * Parse the value of content-light-level caps field and update @minfo
+ * with the parsed values.
+ *
+ * Returns: %TRUE if @linfo points to valid #GstVideoContentLightLevel.
+ */
+gboolean
+gst_video_content_light_level_from_caps_string (GstVideoContentLightLevel *
+    linfo, const gchar * level)
+{
+  guint maxCLL;
+  guint maxFALL;
+
+  g_return_val_if_fail (level != NULL, FALSE);
+
+  if (sscanf (level, "%u:%u", &maxCLL, &maxFALL) == 2) {
+    linfo->maxCLL = maxCLL;
+    linfo->maxFALL = maxFALL;
+    return TRUE;
+  }
+
+  return FALSE;
+}
+
Index: gst-plugins-base-1.16.3/gst-libs/gst/video/video-hdr.h
===================================================================
--- /dev/null
+++ gst-plugins-base-1.16.3/gst-libs/gst/video/video-hdr.h
@@ -0,0 +1,106 @@
+/* GStreamer
+ * Copyright (C) <2018> Seungha Yang <seungha.yang@navercorp.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_VIDEO_HDR_H__
+#define __GST_VIDEO_HDR_H__
+
+#include <gst/gst.h>
+#include <gst/video/video-prelude.h>
+
+G_BEGIN_DECLS
+
+typedef struct _GstVideoHDR GstVideoHDR;
+
+/**
+ * GstVideoMasteringDisplayMetadata:
+ * @Rx: red x coordinate
+ * @Ry: red y coordinate
+ * @Gx: green x coordinate
+ * @Gy: green y coordinate
+ * @Bx: blue x coordinate
+ * @By: blue y coordinate
+ * @Wx: white x coordinate
+ * @Wy: white y coordinate
+ * @max_luma: maximum display luminance
+ * @min_luma: minimum display luminance
+ *
+ * Mastering display color volume information defined by SMPTE ST 2086 (HDR meta).
+ */
+typedef struct {
+  gdouble Rx, Ry;
+  gdouble Gx, Gy;
+  gdouble Bx, By;
+  gdouble Wx, Wy;
+  gdouble max_luma, min_luma;
+} GstVideoMasteringDisplayMetadata;
+
+GST_VIDEO_API
+void      gst_video_mastering_display_metadata_init           (GstVideoMasteringDisplayMetadata * minfo);
+
+GST_VIDEO_API
+gchar *   gst_video_mastering_display_metadata_to_caps_string (const GstVideoMasteringDisplayMetadata * minfo);
+
+GST_VIDEO_API
+gboolean  gst_video_mastering_display_metadata_from_caps_string (GstVideoMasteringDisplayMetadata * minfo,
+                                                                 const gchar * mastering);
+
+GST_VIDEO_API
+gboolean  gst_video_mastering_display_metadata_has_primaries (const GstVideoMasteringDisplayMetadata * minfo);
+
+GST_VIDEO_API
+gboolean  gst_video_mastering_display_metadata_has_luminance (const GstVideoMasteringDisplayMetadata * minfo);
+
+GST_VIDEO_API
+gboolean  gst_video_mastering_display_metadata_is_equal      (const GstVideoMasteringDisplayMetadata * minfo,
+                                                              const GstVideoMasteringDisplayMetadata * other);
+
+/**
+ * GstVideoContentLightMeta:
+ * @maxCLL: Maximum Content Light Level (cd/m^2)
+ * @maxFALL: Maximum Frame-Average Light Leve (cd/m^2)
+ *
+ * Content light level information specified in CEA-861.3, Appendix A.
+ */
+typedef struct {
+  guint maxCLL;
+  guint maxFALL;
+} GstVideoContentLightLevel;
+
+void      gst_video_content_light_level_init                    (GstVideoContentLightLevel * linfo);
+
+GST_VIDEO_API
+gchar *   gst_video_content_light_level_to_caps_string    (const GstVideoContentLightLevel * linfo);
+
+GST_VIDEO_API
+gboolean  gst_video_content_light_level_from_caps_string  (GstVideoContentLightLevel * linfo,
+                                                           const gchar * level);
+
+struct _GstVideoHDR {
+  GstVideoMasteringDisplayMetadata mastering_display_metadata;
+  GstVideoContentLightLevel content_light_level;
+
+  /*< private >*/
+  /* Padding for future extension */
+  gpointer _gst_reserved[GST_PADDING];
+};
+
+G_END_DECLS
+
+#endif
+
Index: gst-plugins-base-1.16.3/gst-libs/gst/video/meson.build
===================================================================
--- gst-plugins-base-1.16.3.orig/gst-libs/gst/video/meson.build
+++ gst-plugins-base-1.16.3/gst-libs/gst/video/meson.build
@@ -33,6 +33,7 @@ video_sources = [
   'videodirection.c',
   'videoorientation.c',
   'videooverlay.c',
+  'video-hdr.c',
 ]
 
 video_headers = [
@@ -69,6 +70,7 @@ video_headers = [
   'video-blend.h',
   'video-overlay-composition.h',
   'video-multiview.h',
+  'video-hdr.h',
 ]
 install_headers(video_headers, subdir : 'gstreamer-1.0/gst/video/')
 
Index: gst-plugins-base-1.16.3/gst-libs/gst/video/video.h
===================================================================
--- gst-plugins-base-1.16.3.orig/gst-libs/gst/video/video.h
+++ gst-plugins-base-1.16.3/gst-libs/gst/video/video.h
@@ -35,6 +35,7 @@ typedef struct _GstVideoAlignment GstVid
 #include <gst/video/video-converter.h>
 #include <gst/video/video-scaler.h>
 #include <gst/video/video-multiview.h>
+#include <gst/video/video-hdr.h>
 
 G_BEGIN_DECLS
 
