From 79a4b3813aa3b9bba86e2c8424c04278bc57009d Mon Sep 17 00:00:00 2001
From: "sheng.liu" <sheng.liu@amlogic.com>
Date: Mon, 28 Nov 2022 15:17:47 +0800
Subject: [PATCH] gstreamer1.0-libav: CF1 do not use avdemux when container is
 wav [1/1]

PD#SWPL-98495

Problem:
avdemux have no case to handle AV_CODEC_ID_PCM_S32LE and AV_CODEC_ID_PCM_S24LE
so tere is no caps to create, the pipeline can not be constructed

Solution:
because avdemux no longer be maintained
do not use avdemux when container is wav

Verify:
AH212
---
 ext/libav/gstavdemux.c | 93 +++++++++++++++++++++---------------------
 1 file changed, 47 insertions(+), 46 deletions(-)

diff --git a/ext/libav/gstavdemux.c b/ext/libav/gstavdemux.c
index 6e16078..6c4dcbc 100755
--- a/ext/libav/gstavdemux.c
+++ b/ext/libav/gstavdemux.c
@@ -913,30 +913,30 @@ gst_ffmpegdemux_create_padname (const gchar * templ, gint n)
   return g_string_free (string, FALSE);
 }
 
-static gboolean
-gst_ffmpegdemux_have_dts_caps (const GstCaps * caps, GstTypeFindProbability prob)
-{
-  GstStructure *s;
-
-  s = gst_caps_get_structure (caps, 0);
-  if (!gst_structure_has_name (s, "audio/x-dts"))
-    return FALSE;
-  /* typefind behavior for DTS:
-   *  MAXIMUM: multiple frame syncs detected, certainly DTS
-   *  LIKELY: single frame sync at offset 0.  Maybe DTS?
-   *  POSSIBLE: single frame sync, not at offset 0.  Highly unlikely
-   *    to be DTS.  */
-  if (prob > GST_TYPE_FIND_LIKELY)
-    return TRUE;
-  if (prob < GST_TYPE_FIND_POSSIBLE)
-    return FALSE;
-  /* for maybe, check for at least a valid-looking rate and channels */
-  if (!gst_structure_has_field (s, "channels"))
-    return FALSE;
-  /* and for extra assurance we could also check the rate from the DTS frame
-   * against the one in the wav header, but for now let's not do that */
-  return gst_structure_has_field (s, "rate");
-}
+static gboolean
+gst_ffmpegdemux_have_dts_caps (const GstCaps * caps, GstTypeFindProbability prob)
+{
+  GstStructure *s;
+
+  s = gst_caps_get_structure (caps, 0);
+  if (!gst_structure_has_name (s, "audio/x-dts"))
+    return FALSE;
+  /* typefind behavior for DTS:
+   *  MAXIMUM: multiple frame syncs detected, certainly DTS
+   *  LIKELY: single frame sync at offset 0.  Maybe DTS?
+   *  POSSIBLE: single frame sync, not at offset 0.  Highly unlikely
+   *    to be DTS.  */
+  if (prob > GST_TYPE_FIND_LIKELY)
+    return TRUE;
+  if (prob < GST_TYPE_FIND_POSSIBLE)
+    return FALSE;
+  /* for maybe, check for at least a valid-looking rate and channels */
+  if (!gst_structure_has_field (s, "channels"))
+    return FALSE;
+  /* and for extra assurance we could also check the rate from the DTS frame
+   * against the one in the wav header, but for now let's not do that */
+  return gst_structure_has_field (s, "rate");
+}
 
 
 static GstFFStream *
@@ -1000,28 +1000,28 @@ gst_ffmpegdemux_get_stream (GstFFMpegDemux * demux, AVStream * avstream)
         gst_caps_set_simple (caps, "parsed", G_TYPE_BOOLEAN, "true",
             "stream-format", G_TYPE_STRING, "byte-stream", NULL);
       }
-  if (!strcmp(demux->context->iformat->name, "wav")) {
-     GstTypeFindProbability prob;
-     AVPacket pkt;
-     gint res = -1;
-     GstCaps *tf_caps;
-     GstBuffer *outbuf = NULL;
+  if (!strcmp(demux->context->iformat->name, "wav")) {
+     GstTypeFindProbability prob;
+     AVPacket pkt;
+     gint res = -1;
+     GstCaps *tf_caps;
+     GstBuffer *outbuf = NULL;
      
-     res = av_read_frame (demux->context, &pkt);
-     outbuf = gst_buffer_new_and_alloc (pkt.size);
-     gst_buffer_fill(outbuf, 0, pkt.data, pkt.size);
-     tf_caps= gst_type_find_helper_for_buffer (GST_OBJECT (pad), outbuf, &prob);
-     if (tf_caps) {
-       GST_LOG ("typefind caps = %" GST_PTR_FORMAT ", P=%d", tf_caps, prob);
-       if (gst_ffmpegdemux_have_dts_caps (tf_caps, prob)) {
-           GST_DEBUG("Found DTS marker in file marked as raw PCM");
-           gst_caps_unref (caps);
-           caps = tf_caps;
-         }
-     }
-     av_packet_unref (&pkt);
-     gst_buffer_unref(outbuf);
-   }
+     res = av_read_frame (demux->context, &pkt);
+     outbuf = gst_buffer_new_and_alloc (pkt.size);
+     gst_buffer_fill(outbuf, 0, pkt.data, pkt.size);
+     tf_caps= gst_type_find_helper_for_buffer (GST_OBJECT (pad), outbuf, &prob);
+     if (tf_caps) {
+       GST_LOG ("typefind caps = %" GST_PTR_FORMAT ", P=%d", tf_caps, prob);
+       if (gst_ffmpegdemux_have_dts_caps (tf_caps, prob)) {
+           GST_DEBUG("Found DTS marker in file marked as raw PCM");
+           gst_caps_unref (caps);
+           caps = tf_caps;
+         }
+     }
+     av_packet_unref (&pkt);
+     gst_buffer_unref(outbuf);
+   }
 
 
   /* stream is known now */
@@ -2169,7 +2169,8 @@ gst_ffmpegdemux_register (GstPlugin * plugin)
         && strcmp (in_plugin->name, "matroska")
         && strcmp (in_plugin->name, "matroska_webm")
         && strcmp (in_plugin->name, "matroska,webm")
-        && strcmp (in_plugin->name, "mpegts")) {
+        && strcmp (in_plugin->name, "mpegts")
+        && strcmp (in_plugin->name, "wav")) {
         rank = GST_RANK_PRIMARY;
     } else {
         /* Set the rank of demuxers known to work to MARGINAL.
-- 
2.25.1

