From c42f1ea0a986618fe428492182b5ab13b2e839a8 Mon Sep 17 00:00:00 2001
From: "xuesong.jiang" <xuesong.jiang@amlogic.com>
Date: Fri, 23 Jul 2021 03:44:38 -0400
Subject: [PATCH 08/30] wait switch expose then seek-final

Change-Id: I4a0405bbb827167bd0a94ae6029d0a1829d03dee
---
 gst-libs/gst/adaptivedemux/gstadaptivedemux.c | 127 +++++++++++++-----
 1 file changed, 96 insertions(+), 31 deletions(-)

diff --git a/gst-libs/gst/adaptivedemux/gstadaptivedemux.c b/gst-libs/gst/adaptivedemux/gstadaptivedemux.c
index df63b02..0749718 100644
--- a/gst-libs/gst/adaptivedemux/gstadaptivedemux.c
+++ b/gst-libs/gst/adaptivedemux/gstadaptivedemux.c
@@ -206,6 +206,12 @@ struct _GstAdaptiveDemuxPrivate
    * without needing to stop tasks when they just want to
    * update the segment boundaries */
   GMutex segment_lock;
+
+  /* AML added for seeking & adapative cross flow */
+  gboolean isSeeking;
+  gboolean isSwitching;
+  GMutex adaptive_switch_lock;
+  GCond adaptive_switch_cond;
 };
 
 typedef struct _GstAdaptiveDemuxTimer
@@ -510,6 +516,12 @@ gst_adaptive_demux_init (GstAdaptiveDemux * demux,
   g_cond_init (&demux->priv->preroll_cond);
   g_mutex_init (&demux->priv->preroll_lock);
 
+  /* AML added for seeking & adapative cross flow */
+  demux->priv->isSeeking = FALSE;
+  demux->priv->isSwitching = FALSE;
+  g_cond_init (&demux->priv->adaptive_switch_cond);
+  g_mutex_init (&demux->priv->adaptive_switch_lock);
+
   pad_template =
       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (klass), "sink");
   g_return_if_fail (pad_template != NULL);
@@ -555,6 +567,10 @@ gst_adaptive_demux_finalize (GObject * object)
   g_cond_clear (&demux->priv->preroll_cond);
   g_mutex_clear (&demux->priv->preroll_lock);
 
+  /* AML added for seeking & adapative cross flow */
+  g_cond_clear (&demux->priv->adaptive_switch_cond);
+  g_mutex_clear (&demux->priv->adaptive_switch_lock);
+
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
@@ -1301,6 +1317,12 @@ gst_adaptive_demux_expose_streams (GstAdaptiveDemux * demux)
 
   GST_DEBUG_OBJECT (demux, "All streams are exposed");
 
+  /* AML added for seeking & adapative cross flow */
+  g_mutex_lock (&demux->priv->adaptive_switch_lock);
+  GST_DEBUG_OBJECT (demux, "signal cond : adaptive_switch_cond for start seek");
+  g_cond_signal (&demux->priv->adaptive_switch_cond);
+  g_mutex_unlock (&demux->priv->adaptive_switch_lock);
+
   return TRUE;
 }
 
@@ -1833,6 +1855,8 @@ gst_adaptive_demux_src_event (GstPad * pad, GstObject * parent,
   switch (event->type) {
     case GST_EVENT_SEEK:
     {
+      GST_DEBUG_OBJECT (demux, "get seek event");
+
       guint32 seqnum = gst_event_get_seqnum (event);
       if (seqnum == demux->priv->segment_seqnum) {
         GST_LOG_OBJECT (pad,
@@ -1840,7 +1864,38 @@ gst_adaptive_demux_src_event (GstPad * pad, GstObject * parent,
         gst_event_unref (event);
         return TRUE;
       }
-      return gst_adaptive_demux_handle_seek_event (demux, pad, event);
+
+      /* AML added for seeking & adapative cross flow */
+      GST_DEBUG_OBJECT (demux, "waiting demux lock");
+      g_print ("waiting demux lock\n");
+      GST_MANIFEST_LOCK (demux);
+      GST_DEBUG_OBJECT (demux, "waitted demux lock");
+      g_print ("waitted demux lock\n");
+      demux->priv->isSeeking = TRUE;
+      GST_DEBUG_OBJECT (demux, "unlock  demux lock after set isSeeking to TRUE");
+      g_print ("unlock  demux lock after set isSeeking to TRUE\n");
+      GST_MANIFEST_UNLOCK (demux);
+      if(demux->priv->isSwitching)
+      {
+        g_mutex_lock (&demux->priv->adaptive_switch_lock);
+        GST_DEBUG_OBJECT (demux, "waiting cond : adaptive_switch_cond");
+        g_print ("waiting cond : adaptive_switch_cond\n");
+        g_cond_wait (&demux->priv->adaptive_switch_cond, &demux->priv->adaptive_switch_lock);
+        GST_DEBUG_OBJECT (demux, "waitted cond : adaptive_switch_cond");
+        g_print ("waitted cond : adaptive_switch_cond\n");
+        g_mutex_unlock (&demux->priv->adaptive_switch_lock);
+      }
+
+      gboolean ret = gst_adaptive_demux_handle_seek_event (demux, pad, event);
+
+    //   g_mutex_lock (&demux->priv->adaptive_switch_lock);
+    //   GST_DEBUG_OBJECT (demux, "waiting cond : adaptive_switch_cond for set seeking flag");
+    //   g_cond_wait (&demux->priv->adaptive_switch_cond, &demux->priv->adaptive_switch_lock);
+    //   GST_DEBUG_OBJECT (demux, "waitted cond : adaptive_switch_cond for set seeking flag");
+    //   demux->priv->isSeeking = FALSE;
+    //   g_mutex_unlock (&demux->priv->adaptive_switch_lock);
+      
+      return ret;
     }
     case GST_EVENT_RECONFIGURE:{
       GstAdaptiveDemuxStream *stream;
@@ -4229,44 +4284,54 @@ gst_adaptive_demux_stream_advance_fragment_unlocked (GstAdaptiveDemux * demux,
   stream->download_start_time =
       GST_TIME_AS_USECONDS (gst_adaptive_demux_get_monotonic_time (demux));
 
-  if (ret == GST_FLOW_OK) {
-    if (gst_adaptive_demux_stream_select_bitrate (demux, stream,
-            gst_adaptive_demux_stream_update_current_bitrate (demux, stream))) {
-      stream->need_header = TRUE;
-      ret = (GstFlowReturn) GST_ADAPTIVE_DEMUX_FLOW_SWITCH;
-    }
+//   if(!strstr(gst_object_get_name(demux), "hls"))
+//   {
+    if (ret == GST_FLOW_OK) {
+        demux->priv->isSwitching = !demux->priv->isSeeking && gst_adaptive_demux_stream_select_bitrate (demux, stream, 
+                                            gst_adaptive_demux_stream_update_current_bitrate (demux, stream));
+        if (demux->priv->isSwitching) {
+        stream->need_header = TRUE;
+        ret = (GstFlowReturn) GST_ADAPTIVE_DEMUX_FLOW_SWITCH;
+        }
+        demux->priv->isSeeking = FALSE;
 
-    /* the subclass might want to switch pads */
-    if (G_UNLIKELY (demux->next_streams)) {
-      GList *iter;
-      gboolean can_expose = TRUE;
+        /* the subclass might want to switch pads */
+        if (G_UNLIKELY (demux->next_streams)) {
+        GList *iter;
+        gboolean can_expose = TRUE;
 
-      gst_task_stop (stream->download_task);
+        gst_task_stop (stream->download_task);
 
-      ret = GST_FLOW_EOS;
+        ret = GST_FLOW_EOS;
 
-      for (iter = demux->streams; iter; iter = g_list_next (iter)) {
-        /* Only expose if all streams are now cancelled or finished downloading */
-        GstAdaptiveDemuxStream *other = iter->data;
-        if (other != stream) {
-          g_mutex_lock (&other->fragment_download_lock);
-          can_expose &= (other->cancelled == TRUE
-              || other->download_finished == TRUE);
-          g_mutex_unlock (&other->fragment_download_lock);
+        for (iter = demux->streams; iter; iter = g_list_next (iter)) {
+            /* Only expose if all streams are now cancelled or finished downloading */
+            GstAdaptiveDemuxStream *other = iter->data;
+            if (other != stream) {
+            g_mutex_lock (&other->fragment_download_lock);
+            can_expose &= (other->cancelled == TRUE
+                || other->download_finished == TRUE);
+            g_mutex_unlock (&other->fragment_download_lock);
+            }
         }
-      }
 
-      if (can_expose) {
-        GST_DEBUG_OBJECT (demux, "Subclass wants new pads "
-            "to do bitrate switching");
-        gst_adaptive_demux_prepare_streams (demux, FALSE);
-        gst_adaptive_demux_start_tasks (demux, TRUE);
-      } else {
-        GST_LOG_OBJECT (demux, "Not switching yet - ongoing downloads");
-      }
+        if (can_expose) {
+            GST_DEBUG_OBJECT (demux, "Subclass wants new pads "
+                "to do bitrate switching");
+            gst_adaptive_demux_prepare_streams (demux, FALSE);
+            gst_adaptive_demux_start_tasks (demux, TRUE);
+        } else {
+            GST_LOG_OBJECT (demux, "Not switching yet - ongoing downloads");
+        }
+        }
     }
-  }
+//   }
 
+//   /* AML added for seeking & adapative cross flow */
+//   g_mutex_lock (&demux->priv->adaptive_switch_lock);
+//   GST_DEBUG_OBJECT (demux, "signal cond : adaptive_switch_cond for set seeking flag");
+//   g_cond_signal (&demux->priv->adaptive_switch_cond);
+//   g_mutex_unlock (&demux->priv->adaptive_switch_lock);
   return ret;
 }
 
-- 
2.34.1

