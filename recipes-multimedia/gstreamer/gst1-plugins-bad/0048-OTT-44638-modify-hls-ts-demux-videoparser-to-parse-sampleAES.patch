diff --git a/ext/hls/gsthlsdemux.c b/ext/hls/gsthlsdemux.c
index 7e6be7a..049b21a 100644
--- a/ext/hls/gsthlsdemux.c
+++ b/ext/hls/gsthlsdemux.c
@@ -61,9 +61,13 @@ GST_DEBUG_CATEGORY (gst_hls_demux_debug);
 #define GST_M3U8_CLIENT_LOCK(l) /* FIXME */
 #define GST_M3U8_CLIENT_UNLOCK(l)       /* FIXME */
 
+
 /* GObject */
 static void gst_hls_demux_finalize (GObject * obj);
 
+static void gst_hls_demux_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec);
+
 /* GstElement */
 static GstStateChangeReturn
 gst_hls_demux_change_state (GstElement * element, GstStateChange transition);
@@ -122,6 +126,12 @@ static gint gst_hls_demux_stream_get_discontinuity_num (GstAdaptiveDemuxStream *
 #define gst_hls_demux_parent_class parent_class
 G_DEFINE_TYPE (GstHLSDemux, gst_hls_demux, GST_TYPE_ADAPTIVE_DEMUX);
 
+enum
+{
+  PROP_0,
+  PROP_USE_HW_DECRYPT,
+};
+
 static void
 gst_hls_demux_finalize (GObject * obj)
 {
@@ -149,9 +159,14 @@ gst_hls_demux_class_init (GstHLSDemuxClass * klass)
   adaptivedemux_class = (GstAdaptiveDemuxClass *) klass;
 
   gobject_class->finalize = gst_hls_demux_finalize;
-
+  gobject_class->set_property = GST_DEBUG_FUNCPTR(gst_hls_demux_set_property);
   element_class->change_state = GST_DEBUG_FUNCPTR (gst_hls_demux_change_state);
 
+  g_object_class_install_property(gobject_class, PROP_USE_HW_DECRYPT,
+      g_param_spec_boolean("use-hw-decrypt", "HW decrypt",
+      "Use hw decrypt",
+      FALSE, G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
+
   gst_element_class_add_static_pad_template (element_class, &srctemplate);
   gst_element_class_add_static_pad_template (element_class, &sinktemplate);
 
@@ -201,6 +216,25 @@ gst_hls_demux_init (GstHLSDemux * demux)
   g_mutex_init (&demux->keys_lock);
 }
 
+void
+gst_hls_demux_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+    GstHLSDemux *demux = GST_HLS_DEMUX(object);
+
+    switch (prop_id) {
+    case PROP_USE_HW_DECRYPT:
+        g_mutex_lock (&demux->keys_lock);
+        demux->use_hw_decrypt = g_value_get_boolean(value);
+        g_mutex_unlock (&demux->keys_lock);
+        GST_INFO_OBJECT (demux, "use hw decrypt %d", demux->use_hw_decrypt);
+        break;
+    default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
+        break;
+    }
+}
+
 static GstStateChangeReturn
 gst_hls_demux_change_state (GstElement * element, GstStateChange transition)
 {
@@ -766,7 +800,7 @@ gst_hls_demux_start_fragment (GstAdaptiveDemux * demux,
       hls_stream->stream_type);
 
   /* If no decryption is needed, there's nothing to be done here */
-  if (hls_stream->current_key == NULL)
+  if (hls_stream->current_key == NULL || hlsdemux->use_hw_decrypt)
     return TRUE;
 
   m3u8 = gst_hls_demux_stream_get_m3u8 (hls_stream);
@@ -855,6 +889,31 @@ gst_hls_demux_handle_buffer (GstAdaptiveDemux * demux,
       return GST_FLOW_OK;
     }
 
+    GST_DEBUG_OBJECT (hlsdemux, "current key method %d", hls_stream->current_key_method);
+    if (hls_stream->current_key_method == GST_HLS_KEY_METHOD_AES128) {
+      guint size = gst_caps_get_size(caps);
+      for (guint i = 0; i < size; i++) {
+        GstStructure *structure = gst_caps_get_structure(caps, i);
+        gst_structure_set (structure,
+                     "original-media-type", G_TYPE_STRING, gst_structure_get_name(structure),
+                     "encryption-algorithm", G_TYPE_STRING, "AES",
+                     "cipher-mode", G_TYPE_STRING, "cbc1",
+                     NULL);
+        gst_structure_set_name(structure, "application/x-aes128-cbc");
+      }
+    } else if (hls_stream->current_key_method == GST_HLS_KEY_METHOD_SAMPLE_AES) {
+      gchar *system_id = "";
+      GstBuffer *key_data = gst_buffer_new_wrapped (g_strdup (hls_stream->current_key_data),
+          strlen (hls_stream->current_key_data));
+      if (hls_stream->current_system_id)
+        system_id = hls_stream->current_system_id;
+
+      GstEvent *event =
+          gst_event_new_protection (system_id, key_data, "hls/sample-aes");
+      gst_adaptive_demux_stream_queue_event(stream, event);
+      gst_buffer_unref(key_data);
+    }
+
     GST_DEBUG_OBJECT (hlsdemux, "Typefind result: %" GST_PTR_FORMAT " prob:%d",
         caps, prob);
 
@@ -892,6 +951,31 @@ gst_hls_demux_handle_buffer (GstAdaptiveDemux * demux,
   }
 
   if (buffer) {
+    if (hls_stream->current_key) {
+      GstBuffer *key = gst_buffer_new_wrapped (g_strdup (hls_stream->current_key), strlen (hls_stream->current_key));
+      GstBuffer *key_id = gst_buffer_new_allocate (NULL, 16, NULL);
+      gst_buffer_fill (key_id, 0, hls_stream->current_key_id, 16);
+      GstBuffer *iv = gst_buffer_new_allocate (NULL, 16, NULL);
+      gst_buffer_fill (iv, 0, hls_stream->current_iv, 16);
+      GstBuffer *kid = hls_stream->have_key_id ? key_id : key; // for verimatrix hls
+
+      GstStructure *crypto_info = gst_structure_new ("application/x-aes128-cbc",
+        "iv_size", G_TYPE_UINT, 16,
+        "kid", GST_TYPE_BUFFER, kid,
+        "iv", GST_TYPE_BUFFER, iv,
+        "encrypted", G_TYPE_BOOLEAN, TRUE,
+         NULL);
+
+      if (hls_stream->current_key_method == GST_HLS_KEY_METHOD_AES128) {
+        gst_structure_set(crypto_info,
+        "cipher-mode", G_TYPE_STRING, "cbc1",
+        NULL);
+      }
+      gst_buffer_add_protection_meta (buffer, crypto_info);
+      gst_buffer_unref(key);
+      gst_buffer_unref(key_id);
+      gst_buffer_unref(iv);
+    }
     buffer = gst_buffer_make_writable (buffer);
     GST_BUFFER_OFFSET (buffer) = hls_stream->current_offset;
     hls_stream->current_offset += gst_buffer_get_size (buffer);
@@ -906,9 +990,10 @@ gst_hls_demux_finish_fragment (GstAdaptiveDemux * demux,
     GstAdaptiveDemuxStream * stream)
 {
   GstHLSDemuxStream *hls_stream = GST_HLS_DEMUX_STREAM_CAST (stream);   // FIXME: pass HlsStream into function
+  GstHLSDemux *hlsdemux = GST_HLS_DEMUX_CAST (demux);
   GstFlowReturn ret = GST_FLOW_OK;
 
-  if (hls_stream->current_key)
+  if (hls_stream->current_key && hlsdemux->use_hw_decrypt == 0)
     gst_hls_demux_stream_decrypt_end (hls_stream);
 
   if (stream->last_ret == GST_FLOW_OK) {
@@ -977,7 +1062,7 @@ gst_hls_demux_data_received (GstAdaptiveDemux * demux,
     hls_stream->current_offset = 0;
 
   /* Is it encrypted? */
-  if (hls_stream->current_key) {
+  if (hls_stream->current_key && hlsdemux->use_hw_decrypt == 0) {
     GError *err = NULL;
     gsize size;
     GstBuffer *tmp_buffer;
@@ -1034,10 +1119,22 @@ gst_hls_demux_stream_free (GstAdaptiveDemuxStream * stream)
     g_free (hls_stream->current_key);
     hls_stream->current_key = NULL;
   }
+  if (hls_stream->current_key_data) {
+    g_free (hls_stream->current_key_data);
+    hls_stream->current_key_data = NULL;
+  }
+  if (hls_stream->current_key_id) {
+    g_free (hls_stream->current_key_id);
+    hls_stream->current_key_id = NULL;
+  }
   if (hls_stream->current_iv) {
     g_free (hls_stream->current_iv);
     hls_stream->current_iv = NULL;
   }
+  if (hls_stream->current_system_id) {
+    g_free (hls_stream->current_system_id);
+    hls_stream->current_system_id = NULL;
+  }
   gst_hls_demux_stream_decrypt_end (hls_stream);
 }
 
@@ -1130,9 +1227,16 @@ gst_hls_demux_update_fragment_info (GstAdaptiveDemuxStream * stream)
 
   g_free (hlsdemux_stream->current_key);
   hlsdemux_stream->current_key = g_strdup (file->key);
+  g_free (hlsdemux_stream->current_key_data);
+  hlsdemux_stream->current_key_data = g_strdup (file->key_data);
+  hlsdemux_stream->current_key_method = file->key_method;
+  hlsdemux_stream->have_key_id = file->have_key_id;
+  g_free (hlsdemux_stream->current_key_id);
+  hlsdemux_stream->current_key_id = g_memdup (file->key_id, sizeof (file->key_id));
   g_free (hlsdemux_stream->current_iv);
   hlsdemux_stream->current_iv = g_memdup (file->iv, sizeof (file->iv));
-
+  g_free (hlsdemux_stream->current_system_id);
+  hlsdemux_stream->current_system_id = g_strdup (file->system_id);
   g_free (stream->fragment.uri);
   stream->fragment.uri = g_strdup (file->uri);
 
diff --git a/ext/hls/gsthlsdemux.h b/ext/hls/gsthlsdemux.h
index 529cd19..c81944d 100644
--- a/ext/hls/gsthlsdemux.h
+++ b/ext/hls/gsthlsdemux.h
@@ -113,7 +113,12 @@ struct _GstHLSDemuxStream
 #endif
 
   gchar     *current_key;
+  gchar     *current_key_data;
+  GstHLSKeyMethod current_key_method;
+  guint8    *current_key_id;
+  gboolean  have_key_id;
   guint8    *current_iv;
+  gchar     *current_system_id;
 
   /* Accumulator for reading PAT/PMT/PCR from
    * the stream so we can set timestamps/segments
@@ -147,6 +152,8 @@ struct _GstHLSDemux
   GstHLSMasterPlaylist *master;
 
   GstHLSVariantStream  *current_variant;
+
+  gboolean              use_hw_decrypt;
 };
 
 struct _GstHLSDemuxClass
diff --git a/ext/hls/m3u8.c b/ext/hls/m3u8.c
index 0ab163c..7931c03 100644
--- a/ext/hls/m3u8.c
+++ b/ext/hls/m3u8.c
@@ -153,6 +153,8 @@ gst_m3u8_media_file_unref (GstM3U8MediaFile * self)
     g_free (self->title);
     g_free (self->uri);
     g_free (self->key);
+    g_free (self->key_data);
+    g_free (self->system_id);
     g_free (self);
   }
 }
@@ -490,13 +492,18 @@ gst_m3u8_update (GstM3U8 * self, gchar * data)
   gchar *title, *end;
   gboolean discontinuity = FALSE;
   gchar *current_key = NULL;
+  gchar *current_key_data = NULL;
+  GstHLSKeyMethod current_key_method = GST_HLS_KEY_METHOD_NONE;
   gboolean have_iv = FALSE;
+  gboolean have_key_id = FALSE;
   guint8 iv[16] = { 0, };
+  guint8 key_id[16] = { 0, };
   gint64 size = -1, offset = -1;
   gint64 mediasequence;
   GList *previous_files = NULL;
   gboolean have_mediasequence = FALSE;
   GstM3U8InitFile *last_init_file = NULL;
+  gchar *current_system_id = NULL;
 
   g_return_val_if_fail (self != NULL, FALSE);
   g_return_val_if_fail (data != NULL, FALSE);
@@ -567,6 +574,10 @@ gst_m3u8_update (GstM3U8 * self, gchar * data)
 
         /* set encryption params */
         file->key = current_key ? g_strdup (current_key) : NULL;
+        file->key_data = current_key_data ? g_strdup (current_key_data) : NULL;
+        file->key_method = current_key_method;
+        file->system_id = current_system_id ? g_strdup (current_system_id) : NULL;
+        file->have_key_id = have_key_id;
         if (file->key) {
           if (have_iv) {
             memcpy (file->iv, iv, sizeof (iv));
@@ -574,6 +585,8 @@ gst_m3u8_update (GstM3U8 * self, gchar * data)
             guint8 *iv = file->iv + 12;
             GST_WRITE_UINT32_BE (iv, file->sequence);
           }
+          if (have_key_id)
+            memcpy (file->key_id, key_id, sizeof (key_id));
         }
 
         if (size != -1) {
@@ -667,10 +680,14 @@ gst_m3u8_update (GstM3U8 * self, gchar * data)
       } else if (g_str_has_prefix (data_ext_x, "KEY:")) {
         gchar *v, *a;
 
+        g_free(current_key_data);
+        current_key_data = NULL;
+        current_key_data = g_strdup(data);
         data = data + 11;
 
         /* IV and KEY are only valid until the next #EXT-X-KEY */
         have_iv = FALSE;
+        have_key_id = FALSE;
         g_free (current_key);
         current_key = NULL;
         while (data && parse_attributes (&data, &a, &v)) {
@@ -708,10 +725,54 @@ gst_m3u8_update (GstM3U8 * self, gchar * data)
             }
             have_iv = TRUE;
           } else if (g_str_equal (a, "METHOD")) {
-            if (!g_str_equal (v, "AES-128")) {
+            if (g_str_equal (v, "AES-128")) {
+              current_key_method = GST_HLS_KEY_METHOD_AES128;
+            } else if (g_str_equal (v, "SAMPLE-AES")) {
+              current_key_method = GST_HLS_KEY_METHOD_SAMPLE_AES;
+            } else {
+              current_key_method = GST_HLS_KEY_METHOD_INVALID;
               GST_WARNING ("Encryption method %s not supported", v);
               continue;
             }
+          } else if (g_str_equal (a, "KEYFORMAT")) {
+            if (g_str_has_prefix (v, "urn:uuid:")) {
+              g_free (current_system_id);
+              current_system_id = NULL;
+              current_system_id = g_strdup (v + 9);
+            } else {
+              GST_WARNING ("Encryption keyformat %s not supported", v);
+              continue;
+            }
+          } else if (g_str_equal (a, "KEYID")) {
+            gchar *keyidp = v;
+            gint i;
+
+            if (strlen (keyidp) < 32 + 2 || (!g_str_has_prefix (keyidp, "0x")
+                    && !g_str_has_prefix (keyidp, "0X"))) {
+              GST_WARNING ("Can't read KEYID");
+              continue;
+            }
+
+            keyidp += 2;
+            for (i = 0; i < 16; i++) {
+              gint h, l;
+
+              h = g_ascii_xdigit_value (*keyidp);
+              keyidp++;
+              l = g_ascii_xdigit_value (*keyidp);
+              keyidp++;
+              if (h == -1 || l == -1) {
+                i = -1;
+                break;
+              }
+              key_id[i] = (h << 4) | l;
+            }
+
+            if (i == -1) {
+              GST_WARNING ("Can't read KEYID");
+              continue;
+            }
+            have_key_id = TRUE;
           }
         }
       } else if (g_str_has_prefix (data_ext_x, "BYTERANGE:")) {
@@ -780,6 +841,12 @@ gst_m3u8_update (GstM3U8 * self, gchar * data)
   g_free (current_key);
   current_key = NULL;
 
+  g_free (current_key_data);
+  current_key_data = NULL;
+
+  g_free (current_system_id);
+  current_system_id = NULL;
+
   self->files = g_list_reverse (self->files);
 
   if (last_init_file)
diff --git a/ext/hls/m3u8.h b/ext/hls/m3u8.h
index 6fd2d84..a07e894 100644
--- a/ext/hls/m3u8.h
+++ b/ext/hls/m3u8.h
@@ -91,6 +91,13 @@ GstM3U8 *          gst_m3u8_ref   (GstM3U8 * m3u8);
 
 void               gst_m3u8_unref (GstM3U8 * m3u8);
 
+typedef enum
+{
+  GST_HLS_KEY_METHOD_INVALID = -1,
+  GST_HLS_KEY_METHOD_NONE,
+  GST_HLS_KEY_METHOD_SAMPLE_AES,
+  GST_HLS_KEY_METHOD_AES128
+} GstHLSKeyMethod;
 
 struct _GstM3U8MediaFile
 {
@@ -100,10 +107,15 @@ struct _GstM3U8MediaFile
   gint64 sequence;               /* the sequence nb of this file */
   gboolean discont;             /* this file marks a discontinuity */
   gchar *key;
+  gchar *key_data;
+  GstHLSKeyMethod key_method;
+  guint8 key_id[16];
   guint8 iv[16];
   gint64 offset, size;
   gint ref_count;               /* ATOMIC */
   GstM3U8InitFile *init_file;   /* Media Initialization (hold ref) */
+  gchar *system_id;
+  gboolean have_key_id;
 };
 
 struct _GstM3U8InitFile
diff --git a/gst-libs/gst/mpegts/gstmpegtsdescriptor.c b/gst-libs/gst/mpegts/gstmpegtsdescriptor.c
index 64e1546..659f8bf 100644
--- a/gst-libs/gst/mpegts/gstmpegtsdescriptor.c
+++ b/gst-libs/gst/mpegts/gstmpegtsdescriptor.c
@@ -805,9 +805,11 @@ gst_mpegts_parse_descriptors (guint8 * buffer, gsize buf_len)
     desc->data = data;
     desc->tag = *data++;
     desc->length = *data++;
+    desc->codec_tag = *(guint32 *)data;
+
     /* Copy the data now that we known the size */
     desc->data = g_memdup (desc->data, desc->length + 2);
-    GST_LOG ("descriptor 0x%02x length:%d", desc->tag, desc->length);
+    GST_LOG ("descriptor 0x%02x length:%d codec_tag %x ", desc->tag, desc->length, desc->codec_tag);
     GST_MEMDUMP ("descriptor", desc->data + 2, desc->length);
     /* extended descriptors */
     if (G_UNLIKELY (desc->tag == 0x7f))
diff --git a/gst-libs/gst/mpegts/gstmpegtsdescriptor.h b/gst-libs/gst/mpegts/gstmpegtsdescriptor.h
index 73f6c74..f45c7a9 100644
--- a/gst-libs/gst/mpegts/gstmpegtsdescriptor.h
+++ b/gst-libs/gst/mpegts/gstmpegtsdescriptor.h
@@ -258,6 +258,7 @@ struct _GstMpegtsDescriptor
   guint8 tag_extension;
   guint8 length;
   guint8 *data;
+  guint32 codec_tag;
 
   /*< private >*/
   /* Padding for future extension */
diff --git a/gst-libs/gst/mpegts/gstmpegtssection.c b/gst-libs/gst/mpegts/gstmpegtssection.c
index 41c970a..a6d0575 100644
--- a/gst-libs/gst/mpegts/gstmpegtssection.c
+++ b/gst-libs/gst/mpegts/gstmpegtssection.c
@@ -713,6 +713,19 @@ _parse_pmt (GstMpegtsSection * section)
         gst_mpegts_parse_descriptors (data, stream_info_length);
     if (stream->descriptors == NULL)
       goto error;
+    if (stream->stream_type == GST_MPEGTS_STREAM_TYPE_VIDEO_HEVC)
+    {
+      GstMpegtsDescriptor *descriptor;
+      for (i = 0; i < stream->descriptors->len; i++) {
+        descriptor = g_ptr_array_index (stream->descriptors, i);
+        GST_LOG ("descriptor 0x%02x length:%d", descriptor->tag, descriptor->length);
+        if (descriptor->tag == 0xF && descriptor->length >= 4
+              && descriptor->codec_tag == GST_MAKE_FOURCC('z','a','v','c')) {
+            GST_LOG("Found a H265 sample-aes stream");
+            stream->stream_type = GST_MPEGTS_STREAM_TYPE_VIDEO_HEVC_AES_128_CBC;
+        }
+      }
+    }
     data += stream_info_length;
 
     i += 1;
diff --git a/gst-libs/gst/mpegts/gstmpegtssection.h b/gst-libs/gst/mpegts/gstmpegtssection.h
index 6054edf..8321e4b 100644
--- a/gst-libs/gst/mpegts/gstmpegtssection.h
+++ b/gst-libs/gst/mpegts/gstmpegtssection.h
@@ -336,7 +336,12 @@ typedef enum {
   GST_MPEGTS_STREAM_TYPE_VIDEO_H264_STEREO_ADDITIONAL_VIEW  = 0x23,
   GST_MPEGTS_STREAM_TYPE_VIDEO_HEVC                   = 0x24,
   /* 0x24 - 0x7e : Rec. ITU-T H.222.0 | ISO/IEC 13818-1 Reserved */
-  GST_MPEGTS_STREAM_TYPE_IPMP_STREAM                  = 0x7f
+  GST_MPEGTS_STREAM_TYPE_IPMP_STREAM                  = 0x7f,
+  GST_MPEGTS_STREAM_TYPE_AUDIO_AAC_ADTS_AES_128_CBC   = 0xcf,
+  GST_MPEGTS_STREAM_TYPE_VIDEO_H264_AES_128_CBC       = 0xdb,
+  GST_MPEGTS_STREAM_TYPE_VIDEO_HEVC_AES_128_CBC       = 0xdc,
+  GST_MPEGTS_STREAM_TYPE_AUDIO_AC3_AES_128_CBC        = 0xc1,
+  GST_MPEGTS_STREAM_TYPE_AUDIO_EAC3_AES_128_CBC       = 0xc2
   /* 0x80 - 0xff : User Private (or defined in other specs) */
 } GstMpegtsStreamType;
 
diff --git a/gst/mpegtsdemux/mpegtsbase.c b/gst/mpegtsdemux/mpegtsbase.c
index ad75110..107cb92 100644
--- a/gst/mpegtsdemux/mpegtsbase.c
+++ b/gst/mpegtsdemux/mpegtsbase.c
@@ -1386,7 +1386,7 @@ mpegts_base_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
   MpegTSBase *base;
   MpegTSPacketizerPacketReturn pret;
   MpegTSPacketizer2 *packetizer;
-  MpegTSPacketizerPacket packet;
+  MpegTSPacketizerPacket packet = {0};
   MpegTSBaseClass *klass;
 
   base = GST_MPEGTS_BASE (parent);
diff --git a/gst/mpegtsdemux/mpegtspacketizer.c b/gst/mpegtsdemux/mpegtspacketizer.c
index 151717d..41297a9 100644
--- a/gst/mpegtsdemux/mpegtspacketizer.c
+++ b/gst/mpegtsdemux/mpegtspacketizer.c
@@ -828,6 +828,10 @@ mpegts_packetizer_next_packet (MpegTSPacketizer2 * packetizer,
   gsize sync_offset;
 
   packet_size = packetizer->packet_size;
+  if (G_UNLIKELY(packet->protection_info)) {
+    gst_structure_free(packet->protection_info);
+    packet->protection_info = NULL;
+  }
   if (G_UNLIKELY (!packet_size)) {
     if (!mpegts_try_discover_packet_size (packetizer))
       return PACKET_NEED_MORE;
@@ -866,7 +870,15 @@ mpegts_packetizer_next_packet (MpegTSPacketizer2 * packetizer,
       GST_LOG ("offset %" G_GUINT64_FORMAT, packet->offset);
       packetizer->offset += packet_size;
       GST_MEMDUMP ("data_start", packet->data_start, 16);
-
+      {
+        GstBufferList *list = gst_adapter_get_buffer_list(packetizer->adapter, gst_adapter_available (packetizer->adapter));
+        GstBuffer *buffer = gst_buffer_list_get(list, 0);
+        GstProtectionMeta *meta = gst_buffer_get_protection_meta(buffer);
+        if (meta) {
+          packet->protection_info = gst_structure_copy(meta->info);
+        }
+        gst_buffer_list_unref(list);
+      }
       return mpegts_packetizer_parse_packet (packetizer, packet);
     }
   }
@@ -878,6 +890,8 @@ mpegts_packetizer_process_next_packet (MpegTSPacketizer2 * packetizer)
   MpegTSPacketizerPacket packet;
   MpegTSPacketizerPacketReturn ret;
 
+  memset(&packet, 0, sizeof(MpegTSPacketizerPacket));
+
   ret = mpegts_packetizer_next_packet (packetizer, &packet);
   if (ret != PACKET_NEED_MORE)
     mpegts_packetizer_clear_packet (packetizer, &packet);
@@ -896,6 +910,10 @@ mpegts_packetizer_clear_packet (MpegTSPacketizer2 * packetizer,
     if (packetizer->map_size - packetizer->map_offset < packet_size)
       mpegts_packetizer_flush_bytes (packetizer, packetizer->map_offset);
   }
+  if (G_LIKELY(packet->protection_info)) {
+    gst_structure_free(packet->protection_info);
+    packet->protection_info = NULL;
+  }
 }
 
 gboolean
diff --git a/gst/mpegtsdemux/mpegtspacketizer.h b/gst/mpegtsdemux/mpegtspacketizer.h
index 6444e81..0f7d4a7 100644
--- a/gst/mpegtsdemux/mpegtspacketizer.h
+++ b/gst/mpegtsdemux/mpegtspacketizer.h
@@ -311,6 +311,7 @@ typedef struct
   guint8  afc_flags;
   guint64 pcr;
   guint64 offset;
+  GstStructure *protection_info;
 } MpegTSPacketizerPacket;
 
 typedef struct
diff --git a/gst/mpegtsdemux/tsdemux.c b/gst/mpegtsdemux/tsdemux.c
index 53e94ac..9408c5d 100644
--- a/gst/mpegtsdemux/tsdemux.c
+++ b/gst/mpegtsdemux/tsdemux.c
@@ -51,6 +51,7 @@
 #include <gst/video/video-color.h>
 
 #include <math.h>
+#include <gst/base/gstbytewriter.h>
 
 #define _gst_log2(x) (log(x)/log(2))
 
@@ -121,6 +122,7 @@ typedef struct _TSDemuxStream TSDemuxStream;
 
 typedef struct _TSDemuxH264ParsingInfos TSDemuxH264ParsingInfos;
 typedef struct _TSDemuxJP2KParsingInfos TSDemuxJP2KParsingInfos;
+typedef struct _TSDemuxADTSParsingInfos TSDemuxADTSParsingInfos;
 
 /* Returns TRUE if a keyframe was found */
 typedef gboolean (*GstTsDemuxKeyFrameScanFunction) (TSDemuxStream * stream,
@@ -147,6 +149,10 @@ struct _TSDemuxJP2KParsingInfos
   /* J2K parsing data */
   gboolean interlace;
 };
+struct _TSDemuxADTSParsingInfos
+{
+  guint mpegversion;
+};
 struct _TSDemuxStream
 {
   MpegTSBaseStream stream;
@@ -215,6 +221,8 @@ struct _TSDemuxStream
   GstTsDemuxKeyFrameScanFunction scan_function;
   TSDemuxH264ParsingInfos h264infos;
   TSDemuxJP2KParsingInfos jp2kInfos;
+  TSDemuxADTSParsingInfos atdsInfos;
+  GstStructure *protection_info;
 
   //for hdcp parse
   gboolean hdcp_content_flag;
@@ -223,6 +231,90 @@ struct _TSDemuxStream
   guchar hdcp_contents[16];
 };
 
+static const struct
+{
+  const guint bit_rate;         /* nominal bit rate */
+  const guint frame_size[3];    /* frame size for 32kHz, 44kHz, and 48kHz */
+} frmsizcod_table[38] = {
+  {
+    32, {
+  64, 69, 96}}, {
+    32, {
+  64, 70, 96}}, {
+    40, {
+  80, 87, 120}}, {
+    40, {
+  80, 88, 120}}, {
+    48, {
+  96, 104, 144}}, {
+    48, {
+  96, 105, 144}}, {
+    56, {
+  112, 121, 168}}, {
+    56, {
+  112, 122, 168}}, {
+    64, {
+  128, 139, 192}}, {
+    64, {
+  128, 140, 192}}, {
+    80, {
+  160, 174, 240}}, {
+    80, {
+  160, 175, 240}}, {
+    96, {
+  192, 208, 288}}, {
+    96, {
+  192, 209, 288}}, {
+    112, {
+  224, 243, 336}}, {
+    112, {
+  224, 244, 336}}, {
+    128, {
+  256, 278, 384}}, {
+    128, {
+  256, 279, 384}}, {
+    160, {
+  320, 348, 480}}, {
+    160, {
+  320, 349, 480}}, {
+    192, {
+  384, 417, 576}}, {
+    192, {
+  384, 418, 576}}, {
+    224, {
+  448, 487, 672}}, {
+    224, {
+  448, 488, 672}}, {
+    256, {
+  512, 557, 768}}, {
+    256, {
+  512, 558, 768}}, {
+    320, {
+  640, 696, 960}}, {
+    320, {
+  640, 697, 960}}, {
+    384, {
+  768, 835, 1152}}, {
+    384, {
+  768, 836, 1152}}, {
+    448, {
+  896, 975, 1344}}, {
+    448, {
+  896, 976, 1344}}, {
+    512, {
+  1024, 1114, 1536}}, {
+    512, {
+  1024, 1115, 1536}}, {
+    576, {
+  1152, 1253, 1728}}, {
+    576, {
+  1152, 1254, 1728}}, {
+    640, {
+  1280, 1393, 1920}}, {
+    640, {
+  1280, 1394, 1920}}
+};
+
 #define VIDEO_CAPS \
   GST_STATIC_CAPS (\
     "video/mpeg, " \
@@ -450,6 +542,11 @@ gst_ts_demux_reset (MpegTSBase * base)
     demux->segment_event = NULL;
   }
 
+  if (demux->protection_event) {
+    gst_event_unref (demux->protection_event);
+    demux->protection_event = NULL;
+  }
+
   if (demux->global_tags) {
     gst_tag_list_unref (demux->global_tags);
     demux->global_tags = NULL;
@@ -1033,6 +1130,11 @@ push_event (MpegTSBase * base, GstEvent * event)
     /* tags are stored to be used after if there are no streams yet,
      * so we should never reject */
     early_ret = TRUE;
+  } else if (GST_EVENT_TYPE (event) == GST_EVENT_PROTECTION) {
+    if (demux->program == NULL) {
+      gst_event_replace(&demux->protection_event, event);
+      early_ret = TRUE;
+    }
   }
 
   if (G_UNLIKELY (demux->program == NULL)) {
@@ -1598,6 +1700,18 @@ create_pad_for_stream (MpegTSBase * base, MpegTSBaseStream * bstream,
           "stream-format", G_TYPE_STRING, "adts", NULL);
       }
       break;
+    case GST_MPEGTS_STREAM_TYPE_AUDIO_AAC_ADTS_AES_128_CBC:
+      is_audio = TRUE;
+      /* prefer mpegversion 4 since it's more commonly supported one */
+      caps = gst_caps_new_simple ("application/x-aes128-cbc",
+          "mpegversion", G_TYPE_INT, 4,
+          "stream-format", G_TYPE_STRING, "adts",
+          "original-media-type", G_TYPE_STRING, "audio/mpeg",
+          "encryption-algorithm", G_TYPE_STRING, "AES",
+          "cipher-mode", G_TYPE_STRING, "cbcs", NULL);
+      /* we will set caps later once parsing adts header is done */
+      stream->atdsInfos.mpegversion = 4;
+      break;
     case GST_MPEGTS_STREAM_TYPE_AUDIO_AAC_LATM:
       is_audio = TRUE;
       if (program->registration_id == DRF_ID_HDCP) {
@@ -1613,12 +1727,44 @@ create_pad_for_stream (MpegTSBase * base, MpegTSBaseStream * bstream,
           "stream-format", G_TYPE_STRING, "loas", NULL);
       }
       break;
+    case GST_MPEGTS_STREAM_TYPE_AUDIO_AC3_AES_128_CBC:
+      is_audio = TRUE;
+      caps = gst_caps_new_simple ("application/x-aes128-cbc",
+          "original-media-type", G_TYPE_STRING, "audio/x-ac3",
+          "encryption-algorithm", G_TYPE_STRING, "AES",
+          "cipher-mode", G_TYPE_STRING, "cbcs", NULL);
+      /* we will set caps later once parsing adts header is done */
+      break;
+    case GST_MPEGTS_STREAM_TYPE_AUDIO_EAC3_AES_128_CBC:
+      is_audio = TRUE;
+      caps = gst_caps_new_simple ("application/x-aes128-cbc",
+          "original-media-type", G_TYPE_STRING, "audio/x-eac3",
+          "encryption-algorithm", G_TYPE_STRING, "AES",
+          "cipher-mode", G_TYPE_STRING, "cbcs", NULL);
+      /* we will set caps later once parsing adts header is done */
+      break;
     case GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG4:
       is_video = TRUE;
       caps = gst_caps_new_simple ("video/mpeg",
           "mpegversion", G_TYPE_INT, 4,
           "systemstream", G_TYPE_BOOLEAN, FALSE, NULL);
       break;
+    case GST_MPEGTS_STREAM_TYPE_VIDEO_H264_AES_128_CBC:
+      is_video = TRUE;
+      caps = gst_caps_new_simple ("application/x-aes128-cbc",
+          "stream-format", G_TYPE_STRING, "byte-stream",
+          "original-media-type", G_TYPE_STRING, "video/x-h264",
+          "encryption-algorithm", G_TYPE_STRING, "AES",
+          "cipher-mode", G_TYPE_STRING, "cbcs", NULL);
+      break;
+    case GST_MPEGTS_STREAM_TYPE_VIDEO_HEVC_AES_128_CBC:
+      is_video = TRUE;
+      caps = gst_caps_new_simple ("application/x-aes128-cbc",
+          "stream-format", G_TYPE_STRING, "byte-stream",
+          "original-media-type", G_TYPE_STRING, "video/x-h265",
+          "encryption-algorithm", G_TYPE_STRING, "AES",
+          "cipher-mode", G_TYPE_STRING, "cbcs", NULL);
+      break;
     case GST_MPEGTS_STREAM_TYPE_VIDEO_H264:
     case GST_MPEGTS_STREAM_TYPE_VIDEO_HEVC:
       is_video = TRUE;
@@ -1986,7 +2132,8 @@ gst_ts_demux_stream_added (MpegTSBase * base, MpegTSBaseStream * bstream,
     }
 
     if (base->mode != BASE_MODE_PUSHING
-        && bstream->stream_type == GST_MPEGTS_STREAM_TYPE_VIDEO_H264) {
+        && (bstream->stream_type == GST_MPEGTS_STREAM_TYPE_VIDEO_H264
+          || bstream->stream_type == GST_MPEGTS_STREAM_TYPE_VIDEO_H264_AES_128_CBC)) {
       stream->scan_function =
           (GstTsDemuxKeyFrameScanFunction) scan_keyframe_h264;
     } else {
@@ -2269,8 +2416,13 @@ gst_ts_demux_program_started (MpegTSBase * base, MpegTSBaseProgram * program)
         GST_DEBUG_OBJECT (stream->pad, "sparse stream, pushing GAP event");
         gst_pad_push_event (stream->pad, gst_event_new_gap (0, 0));
       }
+      if (demux->protection_event) {
+        GstEvent *evt = gst_event_ref(demux->protection_event);
+        gst_pad_push_event(stream->pad, evt);
+      }
     }
 
+    gst_event_replace(&demux->protection_event, NULL);
     gst_element_no_more_pads ((GstElement *) demux);
   }
 }
@@ -2642,6 +2794,9 @@ gst_ts_demux_queue_data (GstTSDemux * demux, TSDemuxStream * stream,
       GST_LOG ("HEADER: Parsing PES header");
 
       /* parse the header */
+      if (packet->protection_info) {
+        stream->protection_info = gst_structure_copy(packet->protection_info);
+      }
       gst_ts_demux_parse_pes_header (demux, stream, data, size, packet->offset);
       break;
     }
@@ -3078,6 +3233,327 @@ error:
   return NULL;
 }
 
+static GstBuffer *
+parse_aac_adts_frame (TSDemuxStream * stream)
+{
+  gint data_location = -1;
+  guint frame_len;
+  guint crc_size;
+  guint mpegversion = 4;
+  GstBuffer *subsamples;
+  GstBuffer *subsamples_buffer;
+  guint offset = 0;
+  gint remain, subsample_count;
+  GstByteWriter *subsample_writer;
+
+  if (stream->current_size < 6) {
+    GST_DEBUG_OBJECT (stream->pad, "Not enough data for header");
+    goto out;
+  }
+
+  subsample_writer = gst_byte_writer_new_with_size(sizeof (guint16) + sizeof (guint32), FALSE);
+  remain = stream->current_size;
+  while (remain > 7 + 16) {
+    /* check syncword */
+    for (guint i = offset; i < stream->current_size - 2; i++) {
+      if ((stream->data[i] == 0xff) && ((stream->data[i + 1] & 0xf6) == 0xf0)) {
+        data_location = i;
+        break;
+      }
+    }
+
+    GST_TRACE_OBJECT (stream->pad, "data location %d", data_location);
+
+    if (data_location == -1) {
+      GST_DEBUG_OBJECT (stream->pad, "Stream does not contain adts syncword");
+      goto out;
+    }
+
+    if (stream->current_size - data_location < 6) {
+      GST_DEBUG_OBJECT (stream->pad, "Not enough data for header");
+      goto out;
+    }
+
+    frame_len = ((stream->data[data_location + 3] & 0x03) << 11) |
+        (stream->data[data_location + 4] << 3) | ((stream->data[data_location +
+                5] & 0xe0) >> 5);
+
+    crc_size = (stream->data[data_location + 1] & 0x01) ? 0 : 2;
+
+    if (frame_len < 7 + 16 + crc_size) {
+      GST_DEBUG_OBJECT (stream->pad, "Invalid frame len %d", frame_len);
+      goto out;
+    }
+
+    mpegversion = (stream->data[data_location + 1] & 0x08) ? 2 : 4;
+
+    offset += frame_len;
+    remain -= frame_len;
+    gst_byte_writer_put_uint16_be (subsample_writer, 7 + crc_size + 16);
+    gst_byte_writer_put_uint32_be (subsample_writer, frame_len - 7 - crc_size - 16);
+    GST_DEBUG_OBJECT (stream->pad, "subsamples %d %d", 7 + crc_size + 16, frame_len - 7 - crc_size - 16);
+  }
+
+  subsamples = gst_byte_writer_free_and_get_buffer(subsample_writer);
+  subsample_count = gst_buffer_get_size(subsamples) / (sizeof (guint16) + sizeof (guint32));
+  GST_DEBUG_OBJECT (stream->pad, "subsamplecount %d ", subsample_count);
+
+  if (stream->protection_info) {
+    gst_structure_set(stream->protection_info,
+      "subsample_count", G_TYPE_UINT, subsample_count,
+      "subsamples", GST_TYPE_BUFFER, subsamples,
+      NULL
+    );
+  }
+
+out:
+  if (mpegversion != stream->atdsInfos.mpegversion) {
+    GstCaps *caps;
+    MpegTSBaseStream *bstream = (MpegTSBaseStream *) stream;
+
+    GST_DEBUG_OBJECT (stream->pad, "Update mpegversion from %d to %d",
+        stream->atdsInfos.mpegversion, mpegversion);
+    stream->atdsInfos.mpegversion = mpegversion;
+
+    caps = gst_stream_get_caps (bstream->stream_object);
+    caps = gst_caps_make_writable (caps);
+
+    gst_caps_set_simple (caps, "mpegversion", G_TYPE_INT, mpegversion, NULL);
+    gst_stream_set_caps (bstream->stream_object, caps);
+    gst_pad_set_caps (stream->pad, caps);
+    gst_caps_unref (caps);
+  }
+
+  return gst_buffer_new_wrapped (stream->data, stream->current_size);
+}
+
+static gboolean
+gst_parse_frame_header_aml_ac3 (TSDemuxStream * stream)
+{
+  gboolean ret = FALSE;
+  GstBitReader bits;
+  guint8 fscod, frmsizcod;
+  gint data_location = -1;
+  guint frame_len;
+  guint offset = 0;
+  guint remain, subsample_count;
+  GstBuffer *subsamples;
+  GstBuffer *subsamples_buffer;
+  GstByteWriter *subsample_writer;
+
+  GST_DEBUG_OBJECT (stream->pad, "parsing aml_ac3");
+
+  if (stream->current_size < 16) {
+    GST_DEBUG_OBJECT (stream->pad, "Not enough data for header");
+    goto out;
+  }
+
+  subsample_writer = gst_byte_writer_new_with_size(sizeof (guint16) + sizeof (guint32), FALSE);
+  remain = stream->current_size;
+  while (remain > 16) {
+    /* check syncword */
+    for (guint i = offset; i < stream->current_size - 2; i++) {
+      if ((stream->data[i] == 0x0b) && (stream->data[i + 1] == 0x77)) {
+        data_location = i;
+        break;
+      }
+    }
+
+    GST_DEBUG_OBJECT (stream->pad, "data location %d", data_location);
+
+    if (data_location == -1) {
+      GST_WARNING ("Stream does not contain aml_ac3 syncword");
+      goto out;
+    }
+
+    if (stream->current_size - data_location < 16) {
+      GST_DEBUG_OBJECT (stream->pad, "Not enough data for header");
+      goto out;
+    }
+
+    gst_bit_reader_init (&bits, stream->data + offset, stream->current_size - offset);
+    gst_bit_reader_skip_unchecked (&bits, 16 + 16);
+    fscod = gst_bit_reader_get_bits_uint8_unchecked (&bits, 2);
+    frmsizcod = gst_bit_reader_get_bits_uint8_unchecked (&bits, 6);
+
+    if (G_UNLIKELY (fscod == 3 || frmsizcod >= G_N_ELEMENTS (frmsizcod_table))) {
+      GST_DEBUG_OBJECT (stream->pad, "bad fscod=%d frmsizcod=%d", fscod, frmsizcod);
+      goto out;
+    }
+
+    frame_len = frmsizcod_table[frmsizcod].frame_size[fscod] * 2;
+    if (frame_len < 16) {
+      GST_ERROR ("Invalid frame len %d", frame_len);
+      goto out;
+    }
+
+    offset += frame_len;
+    remain -= frame_len;
+    gst_byte_writer_put_uint16_be (subsample_writer, 16);
+    gst_byte_writer_put_uint32_be (subsample_writer, frame_len - 16);
+    GST_DEBUG_OBJECT (stream->pad, "subsamples %d %d", 16, frame_len - 16);
+  }
+
+  subsamples = gst_byte_writer_free_and_get_buffer(subsample_writer);
+  subsample_count = gst_buffer_get_size(subsamples) / (sizeof (guint16) + sizeof (guint32));
+  GST_DEBUG_OBJECT (stream->pad, "subsamplecount %d ", subsample_count);
+
+  if (stream->protection_info) {
+    gst_structure_set(stream->protection_info,
+      "subsample_count", G_TYPE_UINT, subsample_count,
+      "subsamples", GST_TYPE_BUFFER, subsamples,
+      NULL
+    );
+  }
+  ret = TRUE;
+out:
+
+  return ret;
+}
+
+static gboolean
+gst_parse_frame_header_aml_eac3 (TSDemuxStream * stream)
+{
+  gboolean ret = FALSE;
+  GstBitReader bits;
+  guint8 strmtyp, strmid, frmsiz, fscod, fscod2;
+  gint data_location = -1;
+  guint frame_len;
+  guint offset = 0;
+  guint remain, subsample_count;
+  GstBuffer *subsamples;
+  GstBuffer *subsamples_buffer;
+  GstByteWriter *subsample_writer;
+
+  GST_DEBUG_OBJECT (stream->pad, "parsing aml_eac3");
+
+  if (stream->current_size < 16) {
+    GST_DEBUG_OBJECT (stream->pad, "Not enough data for header");
+    goto out;
+  }
+
+  subsample_writer = gst_byte_writer_new_with_size(sizeof (guint16) + sizeof (guint32), FALSE);
+  remain = stream->current_size;
+  while (remain > 16) {
+    /* check syncword */
+    for (guint i = offset; i < stream->current_size - 2; i++) {
+      if ((stream->data[i] == 0x0b) && (stream->data[i + 1] == 0x77)) {
+        data_location = i;
+        break;
+      }
+    }
+
+    GST_DEBUG_OBJECT (stream->pad, "data location %d", data_location);
+
+    if (data_location == -1) {
+      GST_WARNING ("Stream does not contain aml_eac3 syncword");
+      goto out;
+    }
+
+    if (stream->current_size - data_location < 16) {
+      GST_DEBUG_OBJECT (stream->pad, "Not enough data for header");
+      goto out;
+    }
+
+    gst_bit_reader_init (&bits, stream->data + offset, stream->current_size - offset);
+    gst_bit_reader_skip_unchecked (&bits, 16);
+    strmtyp = gst_bit_reader_get_bits_uint8_unchecked (&bits, 2);
+    if (G_UNLIKELY (strmtyp == 3)) {
+      GST_DEBUG_OBJECT (stream->pad, "bad strmtyp %d", strmtyp);
+      goto out;
+    }
+    strmid = gst_bit_reader_get_bits_uint8_unchecked (&bits, 3);
+    frmsiz = gst_bit_reader_get_bits_uint16_unchecked (&bits, 11);
+    fscod = gst_bit_reader_get_bits_uint8_unchecked (&bits, 2);
+    if (fscod == 3) {
+      fscod2 = gst_bit_reader_get_bits_uint8_unchecked (&bits, 2);
+      if (G_UNLIKELY (fscod2 == 3)) {
+        GST_DEBUG_OBJECT (stream->pad, "invalid fscod2");
+        goto out;
+      }
+    }
+
+    frame_len = (frmsiz + 1) * 2;
+    if (frame_len < 16) {
+      GST_ERROR ("Invalid frame len %d", frame_len);
+      goto out;
+    }
+
+    offset += frame_len;
+    remain -= frame_len;
+    gst_byte_writer_put_uint16_be (subsample_writer, 16);
+    gst_byte_writer_put_uint32_be (subsample_writer, frame_len - 16);
+    GST_DEBUG_OBJECT (stream->pad, "subsamples %d %d", 16, frame_len - 16);
+  }
+
+  subsamples = gst_byte_writer_free_and_get_buffer(subsample_writer);
+  subsample_count = gst_buffer_get_size(subsamples) / (sizeof (guint16) + sizeof (guint32));
+  GST_DEBUG_OBJECT (stream->pad, "subsamplecount %d ", subsample_count);
+
+  if (stream->protection_info) {
+    gst_structure_set(stream->protection_info,
+      "subsample_count", G_TYPE_UINT, subsample_count,
+      "subsamples", GST_TYPE_BUFFER, subsamples,
+      NULL
+    );
+  }
+  ret = TRUE;
+out:
+
+  return ret;
+}
+
+static GstBuffer *
+parse_aml_ac3_frame (TSDemuxStream * stream)
+{
+  GstBitReader bits;
+  guint16 sync;
+  guint8 bsid;
+  GstMapInfo map;
+  gboolean ret = FALSE;
+  gint skip = 0;
+
+  if (stream->current_size < 16) {
+    GST_DEBUG_OBJECT (stream->pad, "Not enough data for header");
+    goto out;
+  }
+
+  gst_bit_reader_init (&bits, stream->data, stream->current_size);
+
+  gst_bit_reader_skip_unchecked (&bits, skip * 8);
+
+  sync = gst_bit_reader_get_bits_uint16_unchecked (&bits, 16);
+  gst_bit_reader_skip_unchecked (&bits, 16 + 8);
+  bsid = gst_bit_reader_peek_bits_uint8_unchecked (&bits, 5);
+
+  if (G_UNLIKELY (sync != 0x0b77)) {
+    GST_ERROR("unexpected sync %d", sync);
+    goto out;
+  }
+
+  GST_DEBUG_OBJECT (stream->pad, "bsid = %d", bsid);
+
+  if (bsid <= 10) {
+    ret = gst_parse_frame_header_aml_ac3 (stream);
+    if (!ret)
+      GST_ERROR("parse frame header aml_ac3 failed");
+    goto out;
+  } else if (bsid <= 16) {
+    ret = gst_parse_frame_header_aml_eac3 (stream);
+    if (!ret)
+      GST_ERROR("parse frame header aml_eac3 failed");
+    goto out;
+  } else {
+    goto out;
+  }
+
+  GST_DEBUG("unexpected bsid %d", bsid);
+
+out:
+
+  return gst_buffer_new_wrapped (stream->data, stream->current_size);
+}
+
 static GstFlowReturn
 gst_ts_demux_push_pending_data (GstTSDemux * demux, TSDemuxStream * stream,
     MpegTSBaseProgram * target_program)
@@ -3206,6 +3682,20 @@ gst_ts_demux_push_pending_data (GstTSDemux * demux, TSDemuxStream * stream,
         res = GST_FLOW_ERROR;
         goto beach;
       }
+    } else if (bs->stream_type == GST_MPEGTS_STREAM_TYPE_AUDIO_AAC_ADTS
+      || bs->stream_type == GST_MPEGTS_STREAM_TYPE_AUDIO_AAC_ADTS_AES_128_CBC) {
+      buffer = parse_aac_adts_frame (stream);
+      if (!buffer) {
+        res = GST_FLOW_ERROR;
+        goto beach;
+      }
+    } else if (bs->stream_type == GST_MPEGTS_STREAM_TYPE_AUDIO_AC3_AES_128_CBC
+      || bs->stream_type == GST_MPEGTS_STREAM_TYPE_AUDIO_EAC3_AES_128_CBC) {
+      buffer = parse_aml_ac3_frame (stream);
+      if (!buffer) {
+        res = GST_FLOW_ERROR;
+        goto beach;
+      }
     } else {
       buffer = gst_buffer_new_wrapped (stream->data, stream->current_size);
     }
@@ -3349,6 +3839,17 @@ gst_ts_demux_push_pending_data (GstTSDemux * demux, TSDemuxStream * stream,
     demux->segment.position = stream->pts;
 
   if (buffer) {
+    if (stream->protection_info) {
+      if (bs->stream_type == GST_MPEGTS_STREAM_TYPE_VIDEO_H264_AES_128_CBC
+            || bs->stream_type == GST_MPEGTS_STREAM_TYPE_VIDEO_HEVC_AES_128_CBC) {
+        gst_structure_set (stream->protection_info,
+            "crypt_byte_block", G_TYPE_UINT, 1,
+            "skip_byte_block", G_TYPE_UINT, 9,
+            NULL
+        );
+     }
+      gst_buffer_add_protection_meta (buffer, gst_structure_copy(stream->protection_info));
+    }
     res = gst_pad_push (stream->pad, buffer);
     /* Record that a buffer was pushed */
     stream->nb_out_buffers += 1;
@@ -3400,7 +3901,10 @@ beach:
   stream->data = NULL;
   stream->allocated_size = 0;
   stream->current_size = 0;
-
+  if (stream->protection_info) {
+    gst_structure_free(stream->protection_info);
+    stream->protection_info = NULL;
+  }
   return res;
 }
 
diff --git a/gst/mpegtsdemux/tsdemux.h b/gst/mpegtsdemux/tsdemux.h
index 2316518..122eb18 100644
--- a/gst/mpegtsdemux/tsdemux.h
+++ b/gst/mpegtsdemux/tsdemux.h
@@ -105,6 +105,8 @@ struct _GstTSDemux
   /* Used when seeking for a keyframe to go backward in the stream */
   guint64 last_seek_offset;
   guint64 pre_seek_start;
+
+  GstEvent *protection_event;
 };
 
 struct _GstTSDemuxClass
diff --git a/gst/videoparsers/gsth264parse.c b/gst/videoparsers/gsth264parse.c
index aac388b..4017753 100644
--- a/gst/videoparsers/gsth264parse.c
+++ b/gst/videoparsers/gsth264parse.c
@@ -72,20 +72,33 @@ enum
       GST_H264_PARSE_STATE_GOT_SLICE)
 };
 
+enum
+{
+  GST_H264_PARSE_ENCRYPTION_NONE = 0,
+  GST_H264_PARSE_ENCRYPTION_CENC = 1,
+  GST_H264_PARSE_ENCRYPTION_CBCS = 2,
+};
+
 #define GST_H264_PARSE_STATE_VALID(parse, expected_state) \
   (((parse)->state & (expected_state)) == (expected_state))
 
 static GstStaticPadTemplate sinktemplate = GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("video/x-h264"));
+    GST_STATIC_CAPS ("video/x-h264;"
+      "application/x-aes128-cbc,"
+      "original-media-type=(string) video/x-h264;"
+    ));
 
 static GstStaticPadTemplate srctemplate = GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_SRC,
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("video/x-h264, parsed = (boolean) true, "
         "stream-format=(string) { avc, avc3, byte-stream }, "
-        "alignment=(string) { au, nal }"));
+        "alignment=(string) { au, nal };"
+        "application/x-aes128-cbc,"
+        "original-media-type=(string) video/x-h264;"
+        ));
 
 #define parent_class gst_h264_parse_parent_class
 G_DEFINE_TYPE (GstH264Parse, gst_h264_parse, GST_TYPE_BASE_PARSE);
@@ -167,6 +180,7 @@ gst_h264_parse_init (GstH264Parse * h264parse)
 
   h264parse->aud_needed = TRUE;
   h264parse->aud_insert = TRUE;
+  h264parse->encryption_mode = GST_H264_PARSE_ENCRYPTION_NONE;
 }
 
 
@@ -199,6 +213,10 @@ gst_h264_parse_reset_frame (GstH264Parse * h264parse)
   h264parse->have_sps_in_frame = FALSE;
   h264parse->have_pps_in_frame = FALSE;
   gst_adapter_clear (h264parse->frame_out);
+  if (G_LIKELY(h264parse->subsample_writer != NULL)) {
+    gst_byte_writer_free(h264parse->subsample_writer);
+    h264parse->subsample_writer = NULL;
+  }
 }
 
 static void
@@ -811,6 +829,54 @@ gst_h264_parse_process_sei (GstH264Parse * h264parse, GstH264NalUnit * nalu)
   g_array_free (messages, TRUE);
 }
 
+static guint
+find_next_unescape_index(guint8 * data, guint offset, guint limit)
+{
+    for (guint i = offset; i < limit - 2; i++) {
+        if (data[i] == 0x00 && data[i + 1] == 0x00 && data[i + 2] == 0x03) {
+            return i;
+        }
+    }
+    return limit;
+}
+
+/* Unescapes data replacing occurrences of [0, 0, 3] with [0, 0] and returns the new size */
+static guint
+gst_h264_unescape_stream(guint8 * data, guint limit)
+{
+    guint *scratch_escape_positions = (guint *)g_malloc(limit);
+    guint scratch_escape_positions_num = 0;
+    guint position = 0;
+
+    while (position < limit) {
+        position = find_next_unescape_index(data, position, limit);
+        if (position < limit) {
+            scratch_escape_positions[scratch_escape_positions_num] = position;
+            scratch_escape_positions_num++;
+            position += 3;
+        }
+    }
+
+    guint scratch_escape_count = scratch_escape_positions_num;
+    guint escaped_position = 0; /* The position being read from */
+    guint unescaped_position = 0; /* The position being written to */
+    for (guint i = 0; i < scratch_escape_count; i++) {
+        guint next_escape_position = scratch_escape_positions[i];
+        guint copy_length = next_escape_position - escaped_position;
+        memmove(data + unescaped_position, data + escaped_position, copy_length);
+        unescaped_position += copy_length;
+        data[unescaped_position++] = 0;
+        data[unescaped_position++] = 0;
+        escaped_position += copy_length + 3;
+    }
+
+    guint unescaped_length = limit - scratch_escape_count;
+    guint remaining_length = unescaped_length - unescaped_position;
+    memmove(data + unescaped_position, data + escaped_position, remaining_length);
+    g_free(scratch_escape_positions);
+    return unescaped_length;
+}
+
 /* caller guarantees 2 bytes of nal payload */
 static gboolean
 gst_h264_parse_process_nal (GstH264Parse * h264parse, GstH264NalUnit * nalu)
@@ -1002,6 +1068,33 @@ gst_h264_parse_process_nal (GstH264Parse * h264parse, GstH264NalUnit * nalu)
       break;
   }
 
+  if (h264parse->encryption_mode != GST_H264_PARSE_ENCRYPTION_NONE) {
+    if (G_LIKELY(h264parse->subsample_writer == NULL)) {
+      h264parse->subsample_writer = gst_byte_writer_new_with_size(sizeof (guint16) + sizeof (guint32), FALSE);
+    }
+    if (h264parse->encryption_mode == GST_H264_PARSE_ENCRYPTION_CBCS) {
+      guint newSize = 0;
+      switch (nal_type) {
+      case GST_H264_NAL_SLICE:
+      case GST_H264_NAL_SLICE_IDR:
+        if (nalu->size > 48) {
+          newSize = gst_h264_unescape_stream(nalu->data + nalu->offset, nalu->size);
+          nalu->size = newSize;
+          gst_byte_writer_put_uint16_be (h264parse->subsample_writer, 32 + 4);
+          gst_byte_writer_put_uint32_be (h264parse->subsample_writer, nalu->size - 32);
+        } else {
+          gst_byte_writer_put_uint16_be (h264parse->subsample_writer, nalu->size + 4);
+          gst_byte_writer_put_uint32_be (h264parse->subsample_writer, 0);
+        }
+        break;
+      default:
+        gst_byte_writer_put_uint16_be (h264parse->subsample_writer, nalu->size + 4);
+        gst_byte_writer_put_uint32_be (h264parse->subsample_writer, 0);
+        break;
+      }
+    }
+  }
+
   /* if AVC output needed, collect properly prefixed nal in adapter,
    * and use that to replace outgoing buffer data later on */
   if (h264parse->transform) {
@@ -1394,6 +1487,21 @@ end:
 
   gst_h264_parse_parse_frame (parse, frame);
 
+  if (h264parse->encryption_mode != GST_H264_PARSE_ENCRYPTION_NONE) {
+    GstProtectionMeta *meta = gst_buffer_get_protection_meta(frame->out_buffer);
+    GstBuffer *subsamples = gst_byte_writer_free_and_get_buffer(h264parse->subsample_writer);
+    guint subsample_count = gst_buffer_get_size(subsamples) / (sizeof (guint16) + sizeof (guint32));
+    if (meta && meta->info) {
+      gst_structure_set(meta->info,
+        "subsample_count", G_TYPE_UINT, subsample_count,
+        "subsamples", GST_TYPE_BUFFER, subsamples,
+        NULL
+      );
+    }
+    gst_buffer_unref(subsamples);
+    h264parse->subsample_writer = NULL;
+  }
+
   return gst_base_parse_finish_frame (parse, frame, framesize);
 
 more:
@@ -1534,7 +1642,7 @@ gst_h264_parse_get_par (GstH264Parse * h264parse, gint * num, gint * den)
 }
 
 static GstCaps *
-get_compatible_profile_caps (GstH264SPS * sps)
+get_compatible_profile_caps (GstH264Parse * h264parse, GstH264SPS * sps)
 {
   GstCaps *caps = NULL;
   const gchar **profiles = NULL;
@@ -1653,7 +1761,10 @@ get_compatible_profile_caps (GstH264SPS * sps)
 
   if (profiles) {
     GValue value = G_VALUE_INIT;
-    caps = gst_caps_new_empty_simple ("video/x-h264");
+    if (h264parse->encryption_mode == GST_H264_PARSE_ENCRYPTION_CBCS)
+      caps = gst_caps_new_simple ("application/x-aes128-cbc", "original-media-type", G_TYPE_STRING, "video/x-h264", NULL);
+    else
+      caps = gst_caps_new_empty_simple ("video/x-h264");
     for (i = 0; profiles[i]; i++) {
       g_value_init (&value, G_TYPE_STRING);
       g_value_set_string (&value, profiles[i]);
@@ -1676,7 +1787,11 @@ ensure_caps_profile (GstH264Parse * h264parse, GstCaps * caps, GstH264SPS * sps)
 
   peer_caps = gst_pad_get_current_caps (GST_BASE_PARSE_SRC_PAD (h264parse));
   if (!peer_caps || !gst_caps_can_intersect (caps, peer_caps)) {
-    GstCaps *filter_caps = gst_caps_new_empty_simple ("video/x-h264");
+    GstCaps *filter_caps;
+    if (h264parse->encryption_mode == GST_H264_PARSE_ENCRYPTION_CBCS)
+      filter_caps = gst_caps_new_empty_simple ("application/x-aes128-cbc");
+    else
+      filter_caps = gst_caps_new_empty_simple ("video/x-h264");
 
     if (peer_caps)
       gst_caps_unref (peer_caps);
@@ -1690,7 +1805,7 @@ ensure_caps_profile (GstH264Parse * h264parse, GstCaps * caps, GstH264SPS * sps)
   if (peer_caps && !gst_caps_can_intersect (caps, peer_caps)) {
     GstStructure *structure;
 
-    compat_caps = get_compatible_profile_caps (sps);
+    compat_caps = get_compatible_profile_caps (h264parse, sps);
     if (compat_caps != NULL) {
       GstCaps *res_caps = NULL;
 
@@ -2777,6 +2892,8 @@ gst_h264_parse_set_caps (GstBaseParse * parse, GstCaps * caps)
   }
 
   str = gst_caps_get_structure (caps, 0);
+  if (gst_structure_has_name(str, "application/x-aes128-cbc"))
+    h264parse->encryption_mode = GST_H264_PARSE_ENCRYPTION_CBCS;
 
   /* accept upstream info if provided */
   gst_structure_get_int (str, "width", &h264parse->width);
@@ -2928,7 +3045,13 @@ gst_h264_parse_set_caps (GstBaseParse * parse, GstCaps * caps)
     GstCaps *in_caps;
 
     /* prefer input type determined above */
-    in_caps = gst_caps_new_simple ("video/x-h264",
+    if (h264parse->encryption_mode == GST_H264_PARSE_ENCRYPTION_CBCS)
+      in_caps = gst_caps_new_simple ("application/x-aes128-cbc",
+          "original-media-type", G_TYPE_STRING, "video/x-h264",
+          NULL);
+    else
+      in_caps = gst_caps_new_empty_simple ("video/x-h264");
+    gst_caps_set_simple (in_caps,
         "parsed", G_TYPE_BOOLEAN, TRUE,
         "stream-format", G_TYPE_STRING,
         gst_h264_parse_get_string (h264parse, TRUE, format),
diff --git a/gst/videoparsers/gsth264parse.h b/gst/videoparsers/gsth264parse.h
index a8e0120..19fbeb7 100644
--- a/gst/videoparsers/gsth264parse.h
+++ b/gst/videoparsers/gsth264parse.h
@@ -29,6 +29,7 @@
 #include <gst/base/gstbaseparse.h>
 #include <gst/codecparsers/gsth264parser.h>
 #include <gst/video/video.h>
+#include <gst/base/gstbytewriter.h>
 
 G_BEGIN_DECLS
 
@@ -146,6 +147,10 @@ struct _GstH264Parse
   guint8 closedcaptions[96];
   guint closedcaptions_size;
   GstVideoCaptionType closedcaptions_type;
+
+  /* For HW DRM */
+  GstByteWriter *subsample_writer;
+  guint encryption_mode;
 };
 
 struct _GstH264ParseClass
diff --git a/gst/videoparsers/gsth265parse.c b/gst/videoparsers/gsth265parse.c
index 4113710..d38765b 100644
--- a/gst/videoparsers/gsth265parse.c
+++ b/gst/videoparsers/gsth265parse.c
@@ -68,20 +68,31 @@ enum
       GST_H265_PARSE_STATE_GOT_SLICE)
 };
 
+enum
+{
+  GST_H265_PARSE_ENCRYPTION_NONE = 0,
+  GST_H265_PARSE_ENCRYPTION_CENC = 1,
+  GST_H265_PARSE_ENCRYPTION_CBCS = 2,
+};
+
 #define GST_H265_PARSE_STATE_VALID(parse, expected_state) \
   (((parse)->state & (expected_state)) == (expected_state))
 
 static GstStaticPadTemplate sinktemplate = GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("video/x-h265"));
+    GST_STATIC_CAPS ("video/x-h265;"
+        "application/x-aes128-cbc,"
+        "original-media-type=(string) video/x-h265;"));
 
 static GstStaticPadTemplate srctemplate = GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_SRC,
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("video/x-h265, parsed = (boolean) true, "
         "stream-format=(string) { hvc1, hev1, byte-stream }, "
-        "alignment=(string) { au, nal }"));
+        "alignment=(string) { au, nal };"
+        "application/x-aes128-cbc,"
+        "original-media-type=(string) video/x-h265;"));
 
 #define parent_class gst_h265_parse_parent_class
 G_DEFINE_TYPE (GstH265Parse, gst_h265_parse, GST_TYPE_BASE_PARSE);
@@ -157,6 +168,7 @@ gst_h265_parse_init (GstH265Parse * h265parse)
   gst_base_parse_set_pts_interpolation (GST_BASE_PARSE (h265parse), FALSE);
   GST_PAD_SET_ACCEPT_INTERSECT (GST_BASE_PARSE_SINK_PAD (h265parse));
   GST_PAD_SET_ACCEPT_TEMPLATE (GST_BASE_PARSE_SINK_PAD (h265parse));
+  h265parse->encryption_mode = GST_H265_PARSE_ENCRYPTION_NONE;
 }
 
 
@@ -188,6 +200,10 @@ gst_h265_parse_reset_frame (GstH265Parse * h265parse)
   h265parse->have_sps_in_frame = FALSE;
   h265parse->have_pps_in_frame = FALSE;
   gst_adapter_clear (h265parse->frame_out);
+  if (G_LIKELY(h265parse->subsample_writer != NULL)) {
+    gst_byte_writer_free(h265parse->subsample_writer);
+    h265parse->subsample_writer = NULL;
+  }
 }
 
 static void
@@ -559,6 +575,54 @@ gst_h265_parse_process_sei (GstH265Parse * h265parse, GstH265NalUnit * nalu)
   g_array_free (messages, TRUE);
 }
 
+static guint
+find_next_unescape_index(guint8 * data, guint offset, guint limit)
+{
+    for (guint i = offset; i < limit - 2; i++) {
+        if (data[i] == 0x00 && data[i + 1] == 0x00 && data[i + 2] == 0x03) {
+            return i;
+        }
+    }
+    return limit;
+}
+
+/* Unescapes data replacing occurrences of [0, 0, 3] with [0, 0] and returns the new size */
+static guint
+gst_h265_unescape_stream(guint8 * data, guint limit)
+{
+    guint *scratch_escape_positions = (guint *)g_malloc(limit);
+    guint scratch_escape_positions_num = 0;
+    guint position = 0;
+
+    while (position < limit) {
+        position = find_next_unescape_index(data, position, limit);
+        if (position < limit) {
+            scratch_escape_positions[scratch_escape_positions_num] = position;
+            scratch_escape_positions_num++;
+            position += 3;
+        }
+    }
+
+    guint scratch_escape_count = scratch_escape_positions_num;
+    guint escaped_position = 0; /* The position being read from */
+    guint unescaped_position = 0; /* The position being written to */
+    for (guint i = 0; i < scratch_escape_count; i++) {
+        guint next_escape_position = scratch_escape_positions[i];
+        guint copy_length = next_escape_position - escaped_position;
+        memmove(data + unescaped_position, data + escaped_position, copy_length);
+        unescaped_position += copy_length;
+        data[unescaped_position++] = 0;
+        data[unescaped_position++] = 0;
+        escaped_position += copy_length + 3;
+    }
+
+    guint unescaped_length = limit - scratch_escape_count;
+    guint remaining_length = unescaped_length - unescaped_position;
+    memmove(data + unescaped_position, data + escaped_position, remaining_length);
+    g_free(scratch_escape_positions);
+    return unescaped_length;
+}
+
 /* caller guarantees 2 bytes of nal payload */
 static gboolean
 gst_h265_parse_process_nal (GstH265Parse * h265parse, GstH265NalUnit * nalu)
@@ -788,6 +852,33 @@ gst_h265_parse_process_nal (GstH265Parse * h265parse, GstH265NalUnit * nalu)
       break;
   }
 
+  if (h265parse->encryption_mode != GST_H265_PARSE_ENCRYPTION_NONE) {
+    if (G_LIKELY(h265parse->subsample_writer == NULL)) {
+      h265parse->subsample_writer = gst_byte_writer_new_with_size(sizeof (guint16) + sizeof (guint32), FALSE);
+    }
+    if (h265parse->encryption_mode == GST_H265_PARSE_ENCRYPTION_CBCS) {
+        /* calculated values */
+      guint8 *tmp = (guint8 *)nalu->data;
+      if ((nal_type >= GST_H265_NAL_SLICE_TRAIL_N && nal_type <= GST_H265_NAL_SLICE_RASL_R)
+          || (nal_type >= GST_H265_NAL_SLICE_BLA_W_LP && nal_type <= GST_H265_NAL_SLICE_CRA_NUT)) {
+
+        guint newSize = 0;
+        if (nalu->size > 48) {
+          newSize = gst_h265_unescape_stream(nalu->data + nalu->offset, nalu->size);
+          nalu->size = newSize;
+          gst_byte_writer_put_uint16_be (h265parse->subsample_writer, 32 + 4);
+          gst_byte_writer_put_uint32_be (h265parse->subsample_writer, nalu->size - 32);
+        } else {
+          gst_byte_writer_put_uint16_be (h265parse->subsample_writer, nalu->size + 4);
+          gst_byte_writer_put_uint32_be (h265parse->subsample_writer, 0);
+        }
+      } else {
+        gst_byte_writer_put_uint16_be (h265parse->subsample_writer, nalu->size + 4);
+        gst_byte_writer_put_uint32_be (h265parse->subsample_writer, 0);
+      }
+    }
+  }
+
   /* if HEVC output needed, collect properly prefixed nal in adapter,
    * and use that to replace outgoing buffer data later on */
   if (h265parse->transform) {
@@ -1131,6 +1222,21 @@ end:
 
   gst_h265_parse_parse_frame (parse, frame);
 
+  if (h265parse->encryption_mode != GST_H265_PARSE_ENCRYPTION_NONE) {
+    GstProtectionMeta *meta = gst_buffer_get_protection_meta(frame->out_buffer);
+    GstBuffer *subsamples = gst_byte_writer_free_and_get_buffer(h265parse->subsample_writer);
+    guint subsample_count = gst_buffer_get_size(subsamples) / (sizeof (guint16) + sizeof (guint32));
+    if (meta && meta->info) {
+      gst_structure_set(meta->info,
+        "subsample_count", G_TYPE_UINT, subsample_count,
+        "subsamples", GST_TYPE_BUFFER, subsamples,
+        NULL
+      );
+    }
+    gst_buffer_unref(subsamples);
+    h265parse->subsample_writer = NULL;
+  }
+
   return gst_base_parse_finish_frame (parse, frame, framesize);
 
 more:
@@ -1465,7 +1571,7 @@ get_level_string (guint8 level_idc)
 }
 
 static GstCaps *
-get_compatible_profile_caps (GstH265SPS * sps)
+get_compatible_profile_caps (GstH265Parse * h265parse, GstH265SPS * sps)
 {
   GstCaps *caps = NULL;
   const gchar **profiles = NULL;
@@ -1510,7 +1616,12 @@ get_compatible_profile_caps (GstH265SPS * sps)
 
   if (profiles) {
     GValue value = G_VALUE_INIT;
-    caps = gst_caps_new_empty_simple ("video/x-h265");
+    if (h265parse->encryption_mode == GST_H265_PARSE_ENCRYPTION_CBCS)
+      caps = gst_caps_new_simple ("application/x-aes128-cbc",
+                "original-media-type", G_TYPE_STRING, "video/x-h265",
+                NULL);
+    else
+      caps = gst_caps_new_empty_simple ("video/x-h265");
     for (i = 0; profiles[i]; i++) {
       g_value_init (&value, G_TYPE_STRING);
       g_value_set_string (&value, profiles[i]);
@@ -1533,7 +1644,11 @@ ensure_caps_profile (GstH265Parse * h265parse, GstCaps * caps, GstH265SPS * sps)
 
   peer_caps = gst_pad_get_current_caps (GST_BASE_PARSE_SRC_PAD (h265parse));
   if (!peer_caps || !gst_caps_can_intersect (caps, peer_caps)) {
-    GstCaps *filter_caps = gst_caps_new_empty_simple ("video/x-h265");
+    GstCaps *filter_caps;
+    if (h265parse->encryption_mode == GST_H265_PARSE_ENCRYPTION_CBCS)
+      filter_caps = gst_caps_new_empty_simple ("application/x-aes128-cbc");
+    else
+      filter_caps = gst_caps_new_empty_simple ("video/x-h265");
 
     if (peer_caps)
       gst_caps_unref (peer_caps);
@@ -1547,7 +1662,7 @@ ensure_caps_profile (GstH265Parse * h265parse, GstCaps * caps, GstH265SPS * sps)
   if (peer_caps && !gst_caps_can_intersect (caps, peer_caps)) {
     GstStructure *structure;
 
-    compat_caps = get_compatible_profile_caps (sps);
+    compat_caps = get_compatible_profile_caps (h265parse, sps);
     if (compat_caps != NULL) {
       GstCaps *res_caps = NULL;
 
@@ -2329,6 +2444,9 @@ gst_h265_parse_set_caps (GstBaseParse * parse, GstCaps * caps)
 
   str = gst_caps_get_structure (caps, 0);
 
+  if (gst_structure_has_name(str, "application/x-aes128-cbc"))
+    h265parse->encryption_mode = GST_H265_PARSE_ENCRYPTION_CBCS;
+
   /* accept upstream info if provided */
   gst_structure_get_int (str, "width", &h265parse->width);
   gst_structure_get_int (str, "height", &h265parse->height);
@@ -2421,7 +2539,13 @@ gst_h265_parse_set_caps (GstBaseParse * parse, GstCaps * caps)
     GstCaps *in_caps;
 
     /* prefer input type determined above */
-    in_caps = gst_caps_new_simple ("video/x-h265",
+    if (h265parse->encryption_mode == GST_H265_PARSE_ENCRYPTION_CBCS)
+      in_caps = gst_caps_new_simple ("application/x-aes128-cbc",
+                    "original-media-type", G_TYPE_STRING, "video/x-h265",
+                    NULL);
+    else
+      in_caps = gst_caps_new_empty_simple ("video/x-h265");
+    gst_caps_set_simple (in_caps,
         "parsed", G_TYPE_BOOLEAN, TRUE,
         "stream-format", G_TYPE_STRING,
         gst_h265_parse_get_string (h265parse, TRUE, format),
diff --git a/gst/videoparsers/gsth265parse.h b/gst/videoparsers/gsth265parse.h
index f523649..c529c81 100644
--- a/gst/videoparsers/gsth265parse.h
+++ b/gst/videoparsers/gsth265parse.h
@@ -24,6 +24,7 @@
 #include <gst/gst.h>
 #include <gst/base/gstbaseparse.h>
 #include <gst/codecparsers/gsth265parser.h>
+#include <gst/base/gstbytewriter.h>
 
 G_BEGIN_DECLS
 
@@ -111,6 +112,10 @@ struct _GstH265Parse
 
   GstClockTime pending_key_unit_ts;
   GstEvent *force_key_unit_event;
+
+  /* For HW DRM */
+  GstByteWriter *subsample_writer;
+  guint encryption_mode;
 };
 
 struct _GstH265ParseClass
