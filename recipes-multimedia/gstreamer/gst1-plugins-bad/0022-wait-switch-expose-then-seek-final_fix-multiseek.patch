From 778bd688fc116a8dd22952df676df39f3ab5ffe0 Mon Sep 17 00:00:00 2001
From: "xuesong.jiang" <xuesong.jiang@amlogic.com>
Date: Sun, 25 Jul 2021 02:31:43 -0400
Subject: [PATCH 11/30] wait switch expose then seek-final_fix-multiseek

Change-Id: Ida309cfe89dbcef2d4c0576044f4067b9e261121
---
 gst-libs/gst/adaptivedemux/gstadaptivedemux.c | 77 +++++++++++--------
 1 file changed, 46 insertions(+), 31 deletions(-)

diff --git a/gst-libs/gst/adaptivedemux/gstadaptivedemux.c b/gst-libs/gst/adaptivedemux/gstadaptivedemux.c
index 0749718..c79c8fa 100644
--- a/gst-libs/gst/adaptivedemux/gstadaptivedemux.c
+++ b/gst-libs/gst/adaptivedemux/gstadaptivedemux.c
@@ -1875,14 +1875,21 @@ gst_adaptive_demux_src_event (GstPad * pad, GstObject * parent,
       GST_DEBUG_OBJECT (demux, "unlock  demux lock after set isSeeking to TRUE");
       g_print ("unlock  demux lock after set isSeeking to TRUE\n");
       GST_MANIFEST_UNLOCK (demux);
-      if(demux->priv->isSwitching)
+      
+      gint64 end_time;
+      while(demux->priv->isSwitching)
       {
         g_mutex_lock (&demux->priv->adaptive_switch_lock);
         GST_DEBUG_OBJECT (demux, "waiting cond : adaptive_switch_cond");
-        g_print ("waiting cond : adaptive_switch_cond\n");
-        g_cond_wait (&demux->priv->adaptive_switch_cond, &demux->priv->adaptive_switch_lock);
-        GST_DEBUG_OBJECT (demux, "waitted cond : adaptive_switch_cond");
-        g_print ("waitted cond : adaptive_switch_cond\n");
+        //set wait time to 10 ms
+        end_time = g_get_monotonic_time () + 10 * G_TIME_SPAN_MILLISECOND;
+        if(g_cond_wait_until (&demux->priv->adaptive_switch_cond, &demux->priv->adaptive_switch_lock, end_time))
+        {
+            GST_DEBUG_OBJECT (demux, "waitted cond : adaptive_switch_cond");
+            g_mutex_unlock (&demux->priv->adaptive_switch_lock);
+            break;
+        }
+        GST_DEBUG_OBJECT (demux, "continue waiting cond : adaptive_switch_cond or isSwitching == FALSE");
         g_mutex_unlock (&demux->priv->adaptive_switch_lock);
       }
 
@@ -2702,6 +2709,8 @@ _src_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
 
   if (ret == GST_FLOW_FLUSHING) {
     /* do not make any changes if the stream is cancelled */
+    demux->priv->isSwitching = FALSE;
+    GST_DEBUG_OBJECT (demux, "set isSwitching to FALSE when flushing");
     g_mutex_lock (&stream->fragment_download_lock);
     if (G_UNLIKELY (stream->cancelled)) {
       g_mutex_unlock (&stream->fragment_download_lock);
@@ -4289,42 +4298,48 @@ gst_adaptive_demux_stream_advance_fragment_unlocked (GstAdaptiveDemux * demux,
     if (ret == GST_FLOW_OK) {
         demux->priv->isSwitching = !demux->priv->isSeeking && gst_adaptive_demux_stream_select_bitrate (demux, stream, 
                                             gst_adaptive_demux_stream_update_current_bitrate (demux, stream));
+        GST_DEBUG_OBJECT (demux, "GST_FLOW_OK | isSwitching:%d", demux->priv->isSwitching);
         if (demux->priv->isSwitching) {
-        stream->need_header = TRUE;
-        ret = (GstFlowReturn) GST_ADAPTIVE_DEMUX_FLOW_SWITCH;
+            stream->need_header = TRUE;
+            ret = (GstFlowReturn) GST_ADAPTIVE_DEMUX_FLOW_SWITCH;
         }
         demux->priv->isSeeking = FALSE;
 
         /* the subclass might want to switch pads */
         if (G_UNLIKELY (demux->next_streams)) {
-        GList *iter;
-        gboolean can_expose = TRUE;
-
-        gst_task_stop (stream->download_task);
-
-        ret = GST_FLOW_EOS;
-
-        for (iter = demux->streams; iter; iter = g_list_next (iter)) {
-            /* Only expose if all streams are now cancelled or finished downloading */
-            GstAdaptiveDemuxStream *other = iter->data;
-            if (other != stream) {
-            g_mutex_lock (&other->fragment_download_lock);
-            can_expose &= (other->cancelled == TRUE
-                || other->download_finished == TRUE);
-            g_mutex_unlock (&other->fragment_download_lock);
+            GList *iter;
+            gboolean can_expose = TRUE;
+
+            gst_task_stop (stream->download_task);
+
+            ret = GST_FLOW_EOS;
+
+            for (iter = demux->streams; iter; iter = g_list_next (iter)) {
+                /* Only expose if all streams are now cancelled or finished downloading */
+                GstAdaptiveDemuxStream *other = iter->data;
+                if (other != stream) {
+                g_mutex_lock (&other->fragment_download_lock);
+                can_expose &= (other->cancelled == TRUE
+                    || other->download_finished == TRUE);
+                g_mutex_unlock (&other->fragment_download_lock);
+                }
             }
-        }
 
-        if (can_expose) {
-            GST_DEBUG_OBJECT (demux, "Subclass wants new pads "
-                "to do bitrate switching");
-            gst_adaptive_demux_prepare_streams (demux, FALSE);
-            gst_adaptive_demux_start_tasks (demux, TRUE);
-        } else {
-            GST_LOG_OBJECT (demux, "Not switching yet - ongoing downloads");
-        }
+            if (can_expose) {
+                GST_DEBUG_OBJECT (demux, "Subclass wants new pads "
+                    "to do bitrate switching");
+                gst_adaptive_demux_prepare_streams (demux, FALSE);
+                gst_adaptive_demux_start_tasks (demux, TRUE);
+            } else {
+                GST_LOG_OBJECT (demux, "Not switching yet - ongoing downloads");
+            }
         }
     }
+    else
+    {
+        demux->priv->isSwitching = FALSE;
+        GST_DEBUG_OBJECT (demux, "!GST_FLOW_OK | isSwitching:%d", demux->priv->isSwitching);
+    }
 //   }
 
 //   /* AML added for seeking & adapative cross flow */
-- 
2.34.1

