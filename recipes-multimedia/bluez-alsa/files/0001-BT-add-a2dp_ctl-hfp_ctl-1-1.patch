From 9c6efd5728feb2b61536f95c2d53899f5a90eccf Mon Sep 17 00:00:00 2001
From: Weiguang Ruan <Weiguang.ruan@amlogic.com>
Date: Tue, 31 May 2022 19:11:46 +0800
Subject: [PATCH] BT: add a2dp_ctl & hfp_ctl [1/1]

Signed-off-by: Weiguang Ruan <Weiguang.ruan@amlogic.com>
---
 src/shared/ctl-socket.c |  156 ++++++
 src/shared/ctl-socket.h |   42 ++
 utils/Makefile.am       |   18 +
 utils/a2dp_ctl.c        | 1109 +++++++++++++++++++++++++++++++++++++++
 utils/a2dp_ctl.h        |   17 +
 utils/hfp_ctl.c         |  291 ++++++++++
 utils/hfp_ctl.h         |   13 +
 utils/sco_handler.c     |  425 +++++++++++++++
 utils/sco_handler.h     |    4 +
 9 files changed, 2075 insertions(+)
 create mode 100644 src/shared/ctl-socket.c
 create mode 100644 src/shared/ctl-socket.h
 create mode 100644 utils/a2dp_ctl.c
 create mode 100644 utils/a2dp_ctl.h
 create mode 100644 utils/hfp_ctl.c
 create mode 100644 utils/hfp_ctl.h
 create mode 100644 utils/sco_handler.c
 create mode 100644 utils/sco_handler.h

diff --git a/src/shared/ctl-socket.c b/src/shared/ctl-socket.c
new file mode 100644
index 0000000..5d7fa80
--- /dev/null
+++ b/src/shared/ctl-socket.c
@@ -0,0 +1,156 @@
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "shared/ctl-socket.h"
+#include "shared/log.h"
+#include <errno.h>
+
+
+/********************SERVER API***************************/
+
+tAPP_SOCKET * setup_socket_server(const char *path)
+{
+	tAPP_SOCKET *app_socket = calloc(1, sizeof(tAPP_SOCKET));
+
+	if (!app_socket)
+		return NULL;
+
+	strncpy(app_socket->sock_path, path, sizeof(app_socket->sock_path) - 1);
+
+	unlink(path);
+	if ((app_socket->server_sockfd = socket (AF_UNIX, SOCK_STREAM, 0)) < 0) {
+		error("fail to create socket: %s", strerror(errno));
+		return NULL;
+	}
+	app_socket->server_address.sun_family = AF_UNIX;
+	strncpy (app_socket->server_address.sun_path, app_socket->sock_path, sizeof(app_socket->server_address.sun_path));
+	app_socket->server_len = sizeof (app_socket->server_address);
+	app_socket->client_len = sizeof (app_socket->client_address);
+	if ((bind (app_socket->server_sockfd, (struct sockaddr *)&app_socket->server_address, app_socket->server_len)) < 0) {
+		error("bind: %s", strerror(errno));
+		return NULL;
+
+	}
+	if (listen (app_socket->server_sockfd, 10) < 0) {
+		error("listen: %s", strerror(errno));
+		return NULL;
+	}
+	debug("Server is ready for client connect...\n");
+
+	return app_socket;
+}
+
+int accept_client(tAPP_SOCKET *app_socket)
+{
+	int fd;
+	fd = accept (app_socket->server_sockfd, (struct sockaddr *)&app_socket->server_address, (socklen_t *)&app_socket->client_len);
+
+
+	if (fd == -1)
+		error("accept: %s", strerror(errno));
+	else {
+		app_socket->client_sockfd[app_socket->client_seq] = fd;
+		app_socket->client_seq++;
+
+		app_socket->client_seq %= CLIENT_FD_MAX;
+	}
+
+	return fd;
+}
+
+void teardown_socket_server(tAPP_SOCKET *app_socket)
+{
+	unlink (app_socket->sock_path);
+	free(app_socket);
+}
+
+
+void send_all_client(tAPP_SOCKET *app_socket, char *msg, int len)
+{
+	int i;
+	for (i = 0 ; i < CLIENT_FD_MAX; i++) {
+		if (app_socket->client_sockfd[i]) {
+			debug("%s client fd%d", __func__, app_socket->client_sockfd[i]);
+			if (send(app_socket->client_sockfd[i], msg, len, 0) <= 0)
+				error("send msg to sockd %d failed", app_socket->client_sockfd[i]);
+		}
+	}
+}
+
+void shutdown_all_client(tAPP_SOCKET *app_socket)
+{
+	int i;
+	for (i = 0 ; i < CLIENT_FD_MAX; i++) {
+		if (app_socket->client_sockfd[i]) {
+			debug("%s: shutingdown client fd%d", __func__, app_socket->client_sockfd[i]);
+			shutdown(app_socket->client_sockfd[i], SHUT_RDWR);
+		}
+	}
+}
+
+void close_all_clent(tAPP_SOCKET *app_socket)
+{
+	int i;
+	for (i = 0 ; i < CLIENT_FD_MAX; i++) {
+		if (app_socket->client_sockfd[i]) {
+			debug("%s: closing client fd%d", __func__, app_socket->client_sockfd[i]);
+			close(app_socket->client_sockfd[i]);
+		}
+	}
+}
+
+void remove_one_client(tAPP_SOCKET *app_socket, int fd)
+{
+	int i;
+	for (i = 0 ; i < CLIENT_FD_MAX; i++) {
+		if (app_socket->client_sockfd[i] == fd) {
+			debug("%s: remove client fd%d", __func__, app_socket->client_sockfd[i]);
+			app_socket->client_sockfd[i] = 0;
+		}
+	}
+}
+
+void remove_all_client(tAPP_SOCKET *app_socket)
+{
+	int i;
+	for (i = 0 ; i < CLIENT_FD_MAX; i++) {
+		if (app_socket->client_sockfd[i]) {
+			debug("%s: remove client fd%d", __func__, app_socket->client_sockfd[i]);
+			app_socket->client_sockfd[i] = 0;
+		}
+	}
+}
+
+/********************CLIENT API***************************/
+int setup_socket_client(char *socket_path)
+{
+	struct sockaddr_un address;
+	int sockfd,  len;
+
+	if ((sockfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
+		error("%s", strerror(errno));
+		return -1;
+	}
+
+	address.sun_family = AF_UNIX;
+	strncpy (address.sun_path, socket_path, sizeof(address.sun_path) - 1);
+	len = sizeof (address);
+
+	if (connect (sockfd, (struct sockaddr *)&address, len) == -1) {
+		/*if socket is not avialable or not ready, don't report error*/
+		if (errno != 111 && errno != 2)
+			debug("connect server: %s", strerror(errno));
+		close(sockfd);
+		return -1;
+	}
+
+	return sockfd;
+
+}
+
+void teardown_socket_client(int sockfd)
+{
+	close(sockfd);
+}
+
+
diff --git a/src/shared/ctl-socket.h b/src/shared/ctl-socket.h
new file mode 100644
index 0000000..40e8c6b
--- /dev/null
+++ b/src/shared/ctl-socket.h
@@ -0,0 +1,42 @@
+#ifndef _CTL_SOCKET_H
+#define _CTL_SOCKET_H
+
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <stdio.h>
+#include <sys/stat.h>
+
+#define CLIENT_FD_MAX 5
+typedef struct{
+    int server_sockfd;
+    int client_sockfd[CLIENT_FD_MAX];
+    int server_len;
+    int client_len;
+    struct sockaddr_un server_address;
+    struct sockaddr_un client_address;
+    char sock_path[64];
+	int client_seq;
+} tAPP_SOCKET;
+
+
+
+/********************SERVER API***************************/
+
+tAPP_SOCKET * setup_socket_server(const char *path);
+int accept_client(tAPP_SOCKET *app_socket);
+void teardown_socket_server(tAPP_SOCKET *app_socket);
+
+void send_all_client(tAPP_SOCKET *app_socket, char *msg, int len);
+void shutdown_all_client(tAPP_SOCKET *app_socket);
+void close_all_clent(tAPP_SOCKET *app_socket);
+void remove_one_client(tAPP_SOCKET *app_socket, int fd);
+void remove_all_client(tAPP_SOCKET *app_socket);
+
+/********************CLIENT API***************************/
+int setup_socket_client(char *socket_path);
+void teardown_socket_client(int sockfd);
+#endif
+
+
+
diff --git a/utils/Makefile.am b/utils/Makefile.am
index 77425ae..d51b12a 100644
--- a/utils/Makefile.am
+++ b/utils/Makefile.am
@@ -20,6 +20,24 @@ bluealsa_aplay_LDADD = \
 	@GIO2_LIBS@
 endif
 
+bin_PROGRAMS += a2dp_ctl
+a2dp_ctl_SOURCES = a2dp_ctl.c
+a2dp_ctl_CFLAGS = \
+	@GIO2_CFLAGS@
+a2dp_ctl_LDADD = \
+	@GIO2_LIBS@
+
+bin_PROGRAMS += hfp_ctl
+hfp_ctl_SOURCES = hfp_ctl.c \
+	sco_handler.c \
+	../src/shared/log.c \
+	../src/shared/ctl-socket.c
+hfp_ctl_CFLAGS = -lpthread \
+	-I$(top_srcdir)/src \
+	@ALSA_CFLAGS@
+hfp_ctl_LDADD = \
+	@ALSA_LIBS@
+
 if ENABLE_HCITOP
 bin_PROGRAMS += hcitop
 hcitop_CFLAGS = \
diff --git a/utils/a2dp_ctl.c b/utils/a2dp_ctl.c
new file mode 100644
index 0000000..1859cee
--- /dev/null
+++ b/utils/a2dp_ctl.c
@@ -0,0 +1,1109 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+#include <gio/gio.h>
+#include <glib.h>
+#include <pthread.h>
+#include "a2dp_ctl.h"
+
+#define COD_SERVICE_INFORMATION                       (1<<23)
+#define COD_SERVICE_TELEPHONY                         (1<<22)
+#define COD_SERVICE_AUDIO                             (1<<21)
+#define COD_SERVICE_OBJECT_TRANSFER                   (1<<20)
+#define COD_SERVICE_CAPTUREING                        (1<<19)
+#define COD_SERVICE_RENDERING                         (1<<18)
+#define COD_SERVICE_NETWORKING                        (1<<17)
+#define COD_SERVICE_POSITIONING                       (1<<16)
+#define COD_SERVICE_LIMITED_DISCOVERABLE_MODE         (1<<13)
+
+#define GENERIC_AUDIO_UUID	"00001203-0000-1000-8000-00805f9b34fb"
+#define HSP_HS_UUID		"00001108-0000-1000-8000-00805f9b34fb"
+#define HSP_AG_UUID		"00001112-0000-1000-8000-00805f9b34fb"
+#define HFP_HS_UUID		"0000111e-0000-1000-8000-00805f9b34fb"
+#define HFP_AG_UUID		"0000111f-0000-1000-8000-00805f9b34fb"
+#define ADVANCED_AUDIO_UUID	"0000110d-0000-1000-8000-00805f9b34fb"
+#define A2DP_SOURCE_UUID	"0000110a-0000-1000-8000-00805f9b34fb"
+#define A2DP_SINK_UUID		"0000110b-0000-1000-8000-00805f9b34fb"
+#define AVRCP_REMOTE_UUID	"0000110e-0000-1000-8000-00805f9b34fb"
+#define AVRCP_TARGET_UUID	"0000110c-0000-1000-8000-00805f9b34fb"
+#define SCAN_FILTER
+
+#define INFO(fmt, args...) \
+	printf("[A2DP_CTL][%s] " fmt, __func__, ##args)
+
+#define A2DP_CTL_DEBUG 0
+#if A2DP_CTL_DEBUG
+#define DEBUG(fmt, args...) \
+	printf("[A2DP_CTL][DEBUG][%s] " fmt, __func__, ##args)
+#else
+#define DEBUG(fmt, args...)
+#endif
+
+#define TRANSPORT_INTERFACE "org.bluez.MediaTransport1"
+static char TRANSPORT_OBJECT[128] = {0};
+
+#define PLAYER_INTERFACE "org.bluez.MediaPlayer1"
+static char PLAYER_OBJECT[128] = {0};
+
+#define CONTROL_INTERFACE "org.bluez.MediaControl1"
+//static char CONTROL_OBJECT[128] = {0};
+
+#define ADAPTER_INTERFACE "org.bluez.Adapter1"
+static char ADAPTER_OBJECT[128] = {0};
+
+#define DEVICE_INTERFACE "org.bluez.Device1"
+
+static GMainLoop *main_loop;
+static pthread_t thread_id;
+static GDBusConnection *conn;
+static gboolean A2dpConnected = FALSE;
+
+static int call_player_method(char *method);
+static GVariant *get_property(char *obj, char *inf, char *prop);
+static int modify_tansport_volume_property(gboolean up);
+static void *dbus_thread(void *user_data);
+static int call_objManager_method(void);
+static void subscribe_signals(void);
+static void unsubscribe_signals(void);
+static GList *dev_list;
+static char device_mode[11] = "central"; //size of 11 bytes for "peripheral"
+
+gint ifa_signal_handle = 0;
+gint ifr_signal_handle = 0;
+gint pch_signal_handle = 0;
+
+int player_init(void)
+{
+	gchar *address;
+	GError *err = NULL;
+
+	INFO("\n");
+	address = g_dbus_address_get_for_bus_sync(G_BUS_TYPE_SYSTEM, NULL, NULL);
+	if (( conn = g_dbus_connection_new_for_address_sync(address,
+					G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT |
+					G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION,
+					NULL, NULL, &err)) == NULL) {
+		INFO("Couldn't obtain D-Bus connection: %s", err->message);
+		return -1;
+	}
+
+	//check status
+	call_objManager_method();
+	//monitor
+	subscribe_signals();
+
+	if (pthread_create(&thread_id, NULL, dbus_thread, NULL)) {
+		INFO("thread create failed\n");
+		unsubscribe_signals();
+		return -1;
+	}
+
+	return 0;
+}
+
+void player_delinit(void)
+{
+	INFO("\n");
+	unsubscribe_signals();
+	conn = NULL;
+
+	if (NULL != main_loop)
+		g_main_loop_quit(main_loop);
+
+}
+
+int start_play(void)
+{
+	return call_player_method("Play");
+}
+
+int stop_play(void)
+{
+	return call_player_method("Stop");
+}
+
+int pause_play(void)
+{
+	return call_player_method("Pause");
+}
+
+int next(void)
+{
+	return call_player_method("Next");
+}
+
+int previous(void)
+{
+	return call_player_method("Previous");
+}
+
+int volume_up()
+{
+	INFO("\n");
+	return modify_tansport_volume_property(TRUE);
+}
+
+int volume_down()
+{
+	INFO("\n");
+	return modify_tansport_volume_property(FALSE);
+}
+
+void connect_call_back(gboolean connected)
+{
+	if (TRUE == connected) {
+		INFO("A2dp Connected\n");
+		/*works when a2dp connected*/
+
+	} else {
+		INFO("A2dp Disconnected\n");
+		/*works when a2dp disconnected*/
+	}
+
+}
+
+void play_call_back(char *status)
+{
+
+	/*Possible status: "playing", "stopped", "paused"*/
+	if (strcmp("playing", status) == 0) {
+		INFO("Media_Player is now playing\n");
+		/*works when playing*/
+
+	} else if (strcmp("stopped", status) == 0) {
+		INFO("Media_Player stopped\n");
+		/*works when stopped*/
+
+	} else if (strcmp("paused", status) == 0) {
+		INFO("Media_Player paused\n");
+		/*works when paused*/
+
+	}
+}
+
+static void unref_variant(GVariant *v)
+{
+	if (v != NULL)
+		g_variant_unref(v);
+}
+
+static int call_player_method(char *method)
+{
+
+	GVariant *result;
+	GError *error = NULL;
+	int ret = -1;
+	if (NULL == conn) {
+		INFO("No connection!! Please init first\n");
+		return ret;
+	}
+
+	if (NULL == method) {
+		INFO("Invalid args!!\n") ;
+		return ret;
+	}
+
+	if (FALSE == A2dpConnected) {
+		INFO("A2dp not connected yet!\n") ;
+		return ret;
+	}
+
+	if (NULL == method) {
+		INFO("Invalid args!!\n") ;
+		return ret;
+	}
+
+	INFO("args: %s\n", method);
+
+	result = g_dbus_connection_call_sync(conn,
+			"org.bluez",
+			PLAYER_OBJECT,
+			PLAYER_INTERFACE,
+			method,
+			NULL,
+			NULL,
+			G_DBUS_CALL_FLAGS_NONE,
+			-1,
+			NULL,
+			&error);
+
+	if (result == NULL) {
+		INFO("Error: %s\n", error->message);
+		g_error_free (error);
+		return ret;
+	} else
+		ret = 0;
+
+
+	g_variant_unref(result);
+
+	return ret;
+}
+
+static void connect_status(void)
+{
+
+	char dev_obj[256] = {0};
+
+	if (NULL == conn) {
+		INFO("No connection!! Please init first\n");
+		return;
+	}
+
+	if (strncmp("/org/bluez", TRANSPORT_OBJECT, 10) != 0) {
+		INFO("\n\n****Connected Device Information******\n      No Connected Device!!\n\n");
+	} else {
+		/*copy obj_path from trasport, example: /org/bluez/hci0/dev_22_22_B0_69_CE_60/fd4
+		 only the front 37 bytes copied */
+		strncpy(dev_obj, TRANSPORT_OBJECT, 37);
+
+		INFO("\n\n****Connected Device Information******\nName   : %s\nAddress: %s\nState  : %s\n\n",
+			g_variant_get_string(get_property((char *)dev_obj, DEVICE_INTERFACE, "Name"), NULL),
+			g_variant_get_string(get_property((char *)dev_obj, DEVICE_INTERFACE, "Address"), NULL),
+			g_variant_get_string(get_property((char *)TRANSPORT_OBJECT, TRANSPORT_INTERFACE, "State"), NULL));
+	}
+
+	GList *temp = g_list_first(dev_list);
+	while (temp) {
+		if (g_variant_get_boolean(get_property((char *)temp->data, DEVICE_INTERFACE, "Paired")))
+			printf("Paired  Device : %s   %s \n",
+				g_variant_get_string(get_property((char *)temp->data, DEVICE_INTERFACE, "Address"), NULL),
+				g_variant_get_string(get_property((char *)temp->data, DEVICE_INTERFACE, "Name"), NULL));
+		temp = temp->next;
+	}
+}
+#if 0
+static void remove_dev(void)
+{
+
+	GVariant *result;
+	GError *error = NULL;
+
+	if (NULL == conn) {
+		INFO("No connection!! Please init first\n");
+		return;
+	}
+
+	GList *temp = g_list_first(dev_list);
+	while (temp) {
+		INFO("len %d %s\n", g_list_length(dev_list), temp->data);
+
+		if (!g_variant_get_boolean(get_property((char *)temp->data, DEVICE_INTERFACE, "Paired"))) {
+				result = g_dbus_connection_call_sync(conn,
+						"org.bluez",
+						ADAPTER_OBJECT,
+						ADAPTER_INTERFACE,
+						"RemoveDevice",
+						g_variant_new("(o)", (char *)temp->data),
+						NULL,
+						G_DBUS_CALL_FLAGS_NONE,
+						-1,
+						NULL,
+						&error);
+
+				if (result == NULL) {
+					INFO("Error: %s\n", error->message);
+					g_error_free (error);
+				} else
+					g_variant_unref(result);
+		}
+
+		temp = temp->next;
+	}
+
+
+}
+#endif
+
+static void disconnect_dev(void)
+{
+
+	GVariant *result;
+	GError *error = NULL;
+	char obj[256] = {0};
+
+	if (NULL == conn) {
+		INFO("No connection!! Please init first\n");
+		return;
+	}
+
+	if (strncmp("/org/bluez", TRANSPORT_OBJECT, 10) != 0) {
+		INFO("a2dp not connected\n");
+		return;
+	}
+
+	/*copy obj_path from trasport, example: /org/bluez/hci0/dev_22_22_B0_69_CE_60/fd4
+	 only the front 37 bytes copied */
+	strncpy(obj, TRANSPORT_OBJECT, 37);
+
+	INFO("Target obj: %s\n", obj);
+
+	result = g_dbus_connection_call_sync(conn,
+			"org.bluez",
+			obj,
+			DEVICE_INTERFACE,
+			"Disconnect",
+			NULL,
+			NULL,
+			G_DBUS_CALL_FLAGS_NONE,
+			-1,
+			NULL,
+			&error);
+
+	if (result == NULL) {
+		INFO("Error: %s\n", error->message);
+		g_error_free (error);
+	} else
+		g_variant_unref(result);
+}
+
+static int connect_dev(const char* bddr)
+{
+
+	GVariant *result;
+	GError *error = NULL;
+	int ret = 1;
+	char obj[256] = {0};
+
+	if (NULL == conn) {
+		INFO("No connection!! Please init first\n");
+		return ret;
+	}
+
+	if (strlen(bddr) != strlen("xx:xx:xx:xx:xx:xx")) {
+		INFO("Bad bddr\n");
+		return ret;
+	}
+
+	sprintf(obj, "/org/bluez/hci0/dev_%s", bddr);
+
+	INFO("Target obj: %s\n", obj);
+
+	if (strncmp("/org/bluez", TRANSPORT_OBJECT, 10) == 0) {
+		INFO("There is Connected Device\n");
+
+		if (strncmp(obj, TRANSPORT_OBJECT, 37) != 0) {
+			INFO("Disconnect previous device\n");
+			disconnect_dev();
+			sleep(1);
+		}
+	}
+
+	GVariant *param;
+	/*if we are central, we should connect target's sink uuid*/
+	if (strcmp(device_mode, "central") == 0)
+		param = g_variant_new("(s)", A2DP_SINK_UUID);
+	else
+		param = g_variant_new("(s)", A2DP_SOURCE_UUID);
+
+
+	result = g_dbus_connection_call_sync(conn,
+			"org.bluez",
+			obj,
+			DEVICE_INTERFACE,
+			"ConnectProfile",
+			param,
+			NULL,
+			G_DBUS_CALL_FLAGS_NONE,
+			-1,
+			NULL,
+			&error);
+
+	if (result == NULL) {
+		INFO("Error: %s\n", error->message);
+		g_error_free (error);
+		return ret;
+	} else
+		ret = 0;
+
+
+	g_variant_unref(result);
+
+	return ret;
+}
+
+static int set_scan_filter(void)
+{
+
+	GVariant *result;
+	GError *error = NULL;
+	int ret = 0;
+
+	if (NULL == conn) {
+		INFO("No connection!! Please init first\n");
+		return ret;
+	}
+
+#ifdef SCAN_FILTER
+	GVariantBuilder builder;
+	GVariant *dict;
+	GVariant *array;
+	g_variant_builder_init (&builder, G_VARIANT_TYPE ("as"));
+
+
+	/*if we are central, we should discover sink device*/
+	if (strcmp(device_mode, "central") == 0)
+		g_variant_builder_add (&builder, "s", A2DP_SINK_UUID);
+	else
+		g_variant_builder_add (&builder, "s", A2DP_SOURCE_UUID);
+
+	array = g_variant_new("as", &builder);
+	g_variant_builder_clear(&builder);
+
+	g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+	//g_variant_builder_add (&builder, "{sv}", "UUIDs", array);
+	g_variant_builder_add (&builder, "{sv}", "Transport", g_variant_new_string ("bredr"));
+	//g_variant_builder_add (&builder, "{sv}", "RSSI", g_variant_new_int16(0x7fff));
+	//g_variant_builder_add (&builder, "{sv}", "Pathloss", g_variant_new_uint16(0x7fff));
+	//g_variant_builder_add (&builder, "{sv}", "DuplicateData", g_variant_new_boolean(TRUE));
+
+	dict = g_variant_new("(a{sv})", &builder);
+
+	INFO("parameters: %s \n",g_variant_print(dict, TRUE));
+
+	result = g_dbus_connection_call_sync(conn,
+			"org.bluez",
+			ADAPTER_OBJECT,
+			ADAPTER_INTERFACE,
+			"SetDiscoveryFilter",
+			dict,
+			NULL,
+			G_DBUS_CALL_FLAGS_NONE,
+			-1,
+			NULL,
+			&error);
+
+	if (result == NULL) {
+		INFO("Error: %s\n", error->message);
+		g_error_free (error);
+		ret = 1;
+	} else
+		g_variant_unref(result);
+
+	g_variant_builder_clear(&builder);
+#else
+	INFO("skip!!\n");
+#endif
+	return ret;
+}
+
+
+static int adapter_scan(int onoff)
+{
+
+	GVariant *result;
+	GError *error = NULL;
+	int ret = -1;
+	if (NULL == conn) {
+		INFO("No connection!! Please init first\n");
+		return ret;
+	}
+
+	INFO("%s onoff: %d\n", __func__, onoff);
+
+	if (onoff) {
+		set_scan_filter();
+		result = g_dbus_connection_call_sync(conn,
+				"org.bluez",
+				ADAPTER_OBJECT,
+				ADAPTER_INTERFACE,
+				"StartDiscovery",
+				NULL,
+				NULL,
+				G_DBUS_CALL_FLAGS_NONE,
+				G_MAXINT,
+				NULL,
+				&error);
+	} else {
+		result = g_dbus_connection_call_sync(conn,
+				"org.bluez",
+				ADAPTER_OBJECT,
+				ADAPTER_INTERFACE,
+				"StopDiscovery",
+				NULL,
+				NULL,
+				G_DBUS_CALL_FLAGS_NONE,
+				-1,
+				NULL,
+				&error);
+	}
+
+	if (result == NULL) {
+		INFO("Error: %s\n", error->message);
+		g_error_free (error);
+		return ret;
+	} else
+		ret = 0;
+
+
+	g_variant_unref(result);
+
+	return ret;
+}
+
+static GVariant *get_property(char *obj, char *inf, char *prop)
+{
+
+	GVariant *result;
+	GError *error = NULL;
+	if (NULL == conn) {
+		INFO("No connection!! Please init first\n");
+		return NULL;
+	}
+
+	if (strncmp("/org/bluez", obj, 10) != 0) {
+		return NULL;
+	}
+
+	result = g_dbus_connection_call_sync(conn,
+			"org.bluez",
+			obj,
+			"org.freedesktop.DBus.Properties",
+			"Get",
+			g_variant_new("(ss)", inf, prop),
+			NULL,
+			G_DBUS_CALL_FLAGS_NONE,
+			-1,
+			NULL,
+			&error);
+
+	if (result == NULL) {
+		DEBUG("Error: %s\n", error->message);
+		g_error_free (error);
+		return NULL;
+	}
+
+	GVariant *temp = NULL;
+	g_variant_get(result, "(v)", &temp);
+	g_variant_unref(result);
+
+	DEBUG("prop = %s: %s\n", prop, g_variant_print (temp, TRUE));
+
+	return temp;
+}
+
+static int modify_tansport_volume_property(gboolean up)
+{
+
+	GVariant *result = NULL, *child = NULL, *parameters = NULL;
+	int value = 0, temp = 0, ret = -1;
+	GError *error = NULL;
+
+	if (NULL == conn) {
+		INFO("No connection!! Please init first\n");
+		return ret;
+	}
+
+	if (FALSE == A2dpConnected) {
+		INFO("A2dp not connected yet!\n");
+		return ret;
+	}
+
+	/*------------------read volume-----------------------------------------------*/
+	result = g_dbus_connection_call_sync(conn,
+			"org.bluez",
+			TRANSPORT_OBJECT,
+			"org.freedesktop.DBus.Properties",
+			"Get",
+			g_variant_new("(ss)", TRANSPORT_INTERFACE, "Volume"),
+			NULL,
+			G_DBUS_CALL_FLAGS_NONE,
+			-1,
+			NULL,
+			&error);
+
+	if (result == NULL)
+	{
+		INFO("Error: %s\n", error->message);
+		INFO("volume read failed\n");
+		g_error_free (error);
+		return ret;
+	}
+
+	DEBUG("result: %s\n", g_variant_print(result, TRUE));
+	DEBUG("result type : %s\n", g_variant_get_type_string(result));
+	g_variant_get(result, "(v)", &child);
+	g_variant_get(child, "q", &value);
+
+	/*-------------------modify value--------------------------------------------*/
+	temp = value;
+
+	if (TRUE == up)
+		value += 10;
+	else
+		value -= 10;
+
+	//volume rang from 0~127
+	value = value > 127 ? 127 : value;
+	value = value > 0   ? value : 0;
+
+	INFO("volume set: %u->%u\n", temp, value);
+
+	g_variant_unref(child);
+	child = g_variant_new_uint16(value);
+	parameters = g_variant_new("(ssv)",
+			TRANSPORT_INTERFACE,
+			"Volume",
+			child);
+
+	/*------------------set volume-----------------------------------------------*/
+	g_variant_unref(result);
+	result = g_dbus_connection_call_sync(conn,
+			"org.bluez",
+			TRANSPORT_OBJECT,
+			"org.freedesktop.DBus.Properties",
+			"Set",
+			parameters,
+			NULL,
+			G_DBUS_CALL_FLAGS_NONE,
+			-1,
+			NULL,
+			&error);
+
+	if (result == NULL)
+	{
+		INFO("Error: %s\n", error->message);
+		INFO("volume set failed\n");
+		g_error_free (error);
+		return ret;
+	} else
+		ret = 0;
+
+	g_variant_unref(result);
+
+	return ret;
+}
+
+static void signal_interfaces_added(GDBusConnection *conn,
+		const gchar *sender,
+		const gchar *path,
+		const gchar *interface,
+		const gchar *signal,
+		GVariant *params,
+		void *userdata)
+{
+	GVariantIter *interfaces, *interface_content;
+	char *object, *interface_name;
+
+
+	g_variant_get(params, "(oa{sa{sv}})", &object, &interfaces);
+
+	while (g_variant_iter_next(interfaces, "{sa{sv}}", &interface_name, &interface_content)) {
+		if (strcmp(interface_name, TRANSPORT_INTERFACE) == 0) {
+			memset(TRANSPORT_OBJECT, 0, sizeof(TRANSPORT_OBJECT));
+			INFO("Media_Transport registerd: %s\n", object);
+			strncpy(TRANSPORT_OBJECT, object, sizeof(TRANSPORT_OBJECT) -1);
+		} else if (strcmp(interface_name, PLAYER_INTERFACE) == 0) {
+			memset(PLAYER_OBJECT, 0, sizeof(PLAYER_OBJECT));
+			INFO("Media_Player registerd: %s\n", object);
+			strncpy(PLAYER_OBJECT, object, sizeof(PLAYER_OBJECT) - 1);
+		} else if (strcmp(interface_name, CONTROL_INTERFACE) == 0) {
+			INFO("Media_Control registerd: %s\n", object);
+		} else if (strcmp(interface_name, DEVICE_INTERFACE) == 0) {
+			char *temp = malloc(strlen(object) + 1);
+			strcpy(temp, object);
+			dev_list = g_list_append(dev_list, temp);
+		}
+
+		g_free(interface_name);
+		g_variant_iter_free(interface_content);
+	}
+
+	g_variant_iter_free(interfaces);
+	g_free(object);
+
+
+}
+
+static void signal_interfaces_removed(GDBusConnection *conn,
+		const gchar *sender,
+		const gchar *path,
+		const gchar *interface,
+		const gchar *signal,
+		GVariant *params,
+		void *userdata)
+{
+	GVariantIter *interfaces;
+	char *object, *interface_name;
+
+	//	INFO("params type : %s\n", g_variant_get_type_string(params));
+	//	INFO("params: %s\n", g_variant_print(params, TRUE));
+
+	g_variant_get(params, "(oas)", &object, &interfaces);
+
+	while (g_variant_iter_next(interfaces, "s", &interface_name)) {
+		if (strcmp(interface_name, TRANSPORT_INTERFACE) == 0) {
+			INFO("Media_Transport unregisterd\n");
+			//memset(TRANSPORT_OBJECT, 0, sizeof(TRANSPORT_OBJECT));
+		} else if (strcmp(interface_name, PLAYER_INTERFACE) == 0) {
+			INFO("Media_Player unregisterd\n");
+			//memset(PLAYER_OBJECT, 0, sizeof(PLAYER_OBJECT));
+		} else if (strcmp(interface_name, CONTROL_INTERFACE) == 0) {
+			//INFO("Media_Control unregisterd\n");
+		} else if (strcmp(interface_name, DEVICE_INTERFACE) == 0) {
+			GList *temp = g_list_first(dev_list);
+			while (temp) {
+				if (strcmp((char *)temp->data, object) == 0) {
+					/*g_list_remove would change value of temp->data, should free fist */
+					free((char *)temp->data);
+					dev_list = g_list_remove(dev_list, temp->data);
+					break;
+				}
+				temp = temp->next;
+			}
+		}
+
+		g_free(interface_name);
+	}
+
+	g_variant_iter_free(interfaces);
+	g_free(object);
+
+}
+
+static void signal_properties_changed(GDBusConnection *conn,
+		const gchar *sender,
+		const gchar *path,
+		const gchar *interface,
+		const gchar *signal,
+		GVariant *params,
+		void *userdata)
+{
+	GVariantIter *properties;
+	GVariant *value;
+	char *property, *interface_name, *status;
+
+	g_variant_get(params, "(sa{sv}as)", &interface_name, &properties);
+
+	//Media_Control properies handler
+	if (strcmp(interface_name, CONTROL_INTERFACE) == 0) {
+		while (g_variant_iter_next(properties, "{sv}", &property, &value)) {
+			if (strcmp(property, "Connected") == 0) {
+				g_variant_get(value, "b", &A2dpConnected);
+				/*Possible value: TRUE, FALSE*/
+				connect_call_back(A2dpConnected);
+			}
+			g_free(property);
+			g_variant_unref(value);
+		}
+	}
+
+	//Media_Player properies handler
+	if (strcmp(interface_name, PLAYER_INTERFACE) == 0) {
+		while (g_variant_iter_next(properties, "{sv}", &property, &value)) {
+			if (strcmp(property, "Status") == 0) {
+				g_variant_get(value, "s", &status);
+				play_call_back(status);
+			}
+			g_free(property);
+			g_variant_unref(value);
+		}
+	}
+
+	g_free(interface_name);
+	g_variant_iter_free(properties);
+}
+
+static int call_objManager_method(void)
+{
+
+	GVariant *result, *value;
+	GError *error = NULL;
+
+	GVariantIter *iter1, *iter2, *iter3;
+	char *object, *interface_name, *property;
+	gboolean status = FALSE;
+
+	int ret = -1;
+	if (NULL == conn) {
+		INFO("No connection!! Please init first\n");
+		return ret;
+	}
+
+	result = g_dbus_connection_call_sync(conn,
+			"org.bluez",
+			"/",
+			"org.freedesktop.DBus.ObjectManager",
+			"GetManagedObjects",
+			NULL,
+			NULL,
+			G_DBUS_CALL_FLAGS_NONE,
+			-1,
+			NULL,
+			&error);
+
+	if (result == NULL)
+	{
+		INFO("Error: %s\n", error->message);
+		g_error_free (error);
+		return ret;
+	} else
+		ret = 0;
+
+	g_variant_get(result, "(a{oa{sa{sv}}})", &iter1);
+	//g_variant_iter_init(result, &iter1);
+	while (g_variant_iter_next(iter1, "{oa{sa{sv}}}", &object, &iter2)) {
+		while (g_variant_iter_next(iter2, "{sa{sv}}", &interface_name, &iter3)) {
+			//get connected status
+			if (strcmp(interface_name, CONTROL_INTERFACE) == 0) {
+				while (g_variant_iter_next(iter3, "{sv}", &property, &value)) {
+					if (strcmp(property, "Connected") == 0) {
+						g_variant_get(value, "b", &status);
+						//this is the beginng check, only 'TRUE' would be reported
+						if (TRUE == status) {
+							connect_call_back(TRUE);
+							A2dpConnected = TRUE;
+						}
+					}
+					g_free(property);
+					g_variant_unref(value);
+				}
+				//get object path
+			} else if (strcmp(interface_name, TRANSPORT_INTERFACE) == 0) {
+				memset(TRANSPORT_OBJECT, 0, sizeof(TRANSPORT_OBJECT));
+				strncpy(TRANSPORT_OBJECT, object, sizeof(TRANSPORT_OBJECT) - 1);
+				INFO("Media_Transport registerd: %s\n", object);
+			} else if (strcmp(interface_name, PLAYER_INTERFACE) == 0) {
+				memset(PLAYER_OBJECT, 0, sizeof(PLAYER_OBJECT));
+				strncpy(PLAYER_OBJECT, object, sizeof(PLAYER_OBJECT) - 1);
+				INFO("Media_Player registerd: %s\n", object);
+			} else if (strcmp(interface_name, ADAPTER_INTERFACE) == 0) {
+				memset(ADAPTER_OBJECT, 0, sizeof(ADAPTER_OBJECT));
+				strncpy(ADAPTER_OBJECT, object, sizeof(ADAPTER_OBJECT) - 1);
+				INFO("Adapter registerd: %s\n", object);
+			} else if (strcmp(interface_name, DEVICE_INTERFACE) == 0) {
+				/*cache device from last scan*/
+				char *temp = malloc(strlen(object) + 1);
+				strcpy(temp, object);
+				dev_list = g_list_append(dev_list, temp);
+			}
+
+			g_free(interface_name);
+			g_variant_iter_free(iter3);
+		}
+		g_free(object);
+		g_variant_iter_free(iter2);
+	}
+
+	g_variant_iter_free(iter1);
+	g_variant_unref(result);
+	return ret;
+}
+
+static void subscribe_signals(void)
+{
+	//we monitor interface added here
+	ifa_signal_handle = g_dbus_connection_signal_subscribe(conn, "org.bluez", "org.freedesktop.DBus.ObjectManager",
+			"InterfacesAdded", NULL, NULL, G_DBUS_SIGNAL_FLAGS_NONE,
+			signal_interfaces_added, NULL, NULL);
+
+	//we monitor interface remove here
+	ifr_signal_handle = g_dbus_connection_signal_subscribe(conn, "org.bluez", "org.freedesktop.DBus.ObjectManager",
+			"InterfacesRemoved", NULL, NULL, G_DBUS_SIGNAL_FLAGS_NONE,
+			signal_interfaces_removed, NULL, NULL);
+
+	//we monitor propertes changed here
+	pch_signal_handle = g_dbus_connection_signal_subscribe(conn, "org.bluez", "org.freedesktop.DBus.Properties",
+			"PropertiesChanged", NULL, NULL, G_DBUS_SIGNAL_FLAGS_NONE,
+			signal_properties_changed, NULL, NULL);
+
+}
+
+static void unsubscribe_signals(void)
+{
+	g_dbus_connection_signal_unsubscribe(conn, ifa_signal_handle);
+	g_dbus_connection_signal_unsubscribe(conn, ifr_signal_handle);
+	g_dbus_connection_signal_unsubscribe(conn, pch_signal_handle);
+
+}
+
+static void *dbus_thread(void *user_data)
+{
+	main_loop = g_main_loop_new(NULL, FALSE);
+	g_main_loop_run(main_loop);
+
+	return NULL;
+}
+
+
+int main(int argc, void **argv)
+{
+	int i, ret = 0;
+	int timeout = 10;
+	char *bddr = NULL;
+	if (player_init())
+		return 1;
+
+
+	while (timeout > 0) {
+		if (strncmp("/org/bluez", ADAPTER_OBJECT, 10) == 0)
+			break;
+		sleep(1);
+		timeout--;
+	}
+
+	if (timeout == 0) {
+		INFO("adapter not found!!, exit!!");
+		return 1;
+	}
+
+	if (argc > 1) {
+
+		if (argc > 3)
+			if (strstr(argv[3], "peripheral"))
+				strcpy(device_mode, "peripheral");
+
+		INFO("device_mode = %s\n", device_mode);
+
+		if (strcmp(argv[1], "scan") == 0) {
+			sleep(1);
+
+			//remove_dev();
+
+			adapter_scan(1);
+			INFO("scanning....\n");
+
+			timeout = 5;
+			if (argc > 2)
+				timeout = atoi(argv[2]);
+
+			timeout = (timeout > 0   ? timeout : 1);
+			timeout = (timeout < 180 ? timeout : 180);
+			INFO("scan timeout = %ds\n", timeout);
+			sleep(timeout);
+
+			adapter_scan(0);
+			GList *temp = g_list_first(dev_list);
+
+			GVariant *g1, *g2, *g3, *g4;
+			const gchar *addr, *name;
+			gchar *uuids = NULL;
+			guint class = 0;
+			gsize uuid_len = 0;
+			guint device_type = 0;
+			while (temp) {
+				g1 = get_property((char *)temp->data, DEVICE_INTERFACE, "Address");
+				if (g1 != NULL)
+					addr = g_variant_get_string(g1, NULL);
+				else
+					addr = "(null)";
+				g2 = get_property((char *)temp->data, DEVICE_INTERFACE, "Name");
+				if (g2 != NULL)
+					name = g_variant_get_string(g2, NULL);
+				else
+					name = "(null)";
+				g3 = get_property((char *)temp->data, DEVICE_INTERFACE, "Class");
+				if (g3 != NULL)
+					g_variant_get(g3, "u", &class);
+				else
+					class = 0;
+
+				g4 = get_property((char *)temp->data, DEVICE_INTERFACE, "UUIDs");
+				if (g4 != NULL) {
+					const gchar **astr = g_variant_get_strv (g4, &uuid_len);
+					uuids = malloc(uuid_len * (strlen(A2DP_SINK_UUID) + 3));
+					if (!uuids) {
+						INFO("fail to alloc uuids\n");
+						ret = -1;
+						goto error;
+					}
+
+					memset(uuids, 0,  uuid_len * (strlen(A2DP_SINK_UUID) + 3));
+					for (i = 0 ; i < uuid_len; i++) {
+						strcat(uuids, astr[i]);
+						strcat(uuids, " ");
+					}
+				}
+
+				DEBUG("Device Props: %s %s 0x%x\n%s\n", addr, name, class, (uuids == NULL ? "(null)" : uuids));
+
+				if (uuids != NULL) {
+					if (strcmp(device_mode, "central") == 0) {
+						if (strstr(uuids, A2DP_SINK_UUID) || ((class & COD_SERVICE_AUDIO) && (class & COD_SERVICE_RENDERING)))
+							INFO("A2DP-SINK Device found: %s %s\n", addr, name);
+					} else {
+						if (strstr(uuids, A2DP_SOURCE_UUID) || (class & COD_SERVICE_CAPTUREING))
+							INFO("A2DP-SOURCE Device found: %s %s\n", addr, name);
+					}
+					free(uuids);
+					uuids = NULL;
+				}
+				unref_variant(g1);
+				unref_variant(g2);
+				unref_variant(g3);
+				unref_variant(g4);
+
+				temp = temp->next;
+			}
+		} else if (strcmp(argv[1], "scanoff") == 0) {
+			adapter_scan(0);
+		} else if (strcmp(argv[1], "connect") == 0) {
+			if (argc > 2) {
+				bddr = argv[2];
+				INFO("connec target : %s\n", bddr);
+				bddr[2] = bddr[5] = bddr[8] = bddr[11] = bddr[14] = '_';
+
+				ret = connect_dev(bddr);
+				if (!ret)
+					INFO("\n*********************\n* Device Connected! *\n*********************\n");
+
+			} else {
+				INFO("please set bddr!!");
+				ret = 1;
+			}
+		} else if (strcmp(argv[1], "disconnect") == 0) {
+			disconnect_dev();
+		} else if (strcmp(argv[1], "status") == 0) {
+			connect_status();
+		}
+	}
+error:
+	player_delinit();
+
+	return ret;
+
+}
+#if 0
+int main(int argc, void *argv)
+{
+	int i;
+	if (player_init())
+		return 0;
+
+	while (A2dpConnected == FALSE) {
+		sleep(1);
+		INFO("waiting for connection\n");
+	}
+
+	INFO("Device connected, start playing\n");
+	start_play();
+	sleep(10);
+#if 0
+	pause_play();
+	sleep(2);
+	next();
+	sleep(2);
+	previous();
+	sleep(2);
+	for (i = 0 ; i < 5; i++) {
+		volume_down();
+		sleep(1);
+	}
+
+	for (i = 0 ; i < 5; i++) {
+		volume_up();
+		sleep(1);
+	}
+#endif
+
+	stop_play();
+	sleep(2);
+
+	player_delinit();
+
+	return 0;
+
+}
+#endif
diff --git a/utils/a2dp_ctl.h b/utils/a2dp_ctl.h
new file mode 100644
index 0000000..ddaa2ae
--- /dev/null
+++ b/utils/a2dp_ctl.h
@@ -0,0 +1,17 @@
+#ifndef _CT_H_
+#define _CT_H_
+
+
+int player_init(void);
+void player_delinit(void);
+int start_play(void);
+int stop_play(void);
+int pause_play(void);
+int next(void);
+int previous(void);
+int volume_up();
+int volume_down();
+void connect_call_back(gboolean connected);
+void play_call_back(char *status);
+
+#endif
diff --git a/utils/hfp_ctl.c b/utils/hfp_ctl.c
new file mode 100644
index 0000000..9f114fd
--- /dev/null
+++ b/utils/hfp_ctl.c
@@ -0,0 +1,291 @@
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <signal.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include "shared/ctl-socket.h"
+#include "hfp_ctl.h"
+#include "sco_handler.h"
+
+
+#define INFO(fmt, args...) \
+	printf("[HFP_CTL][%s] " fmt, __func__, ##args)
+
+
+static int hfp_ctl_sk = 0;
+static unsigned int sVol = 10;
+static unsigned int mVol = 10;
+static int hfp_connected = 0;
+static pthread_t phfp_ctl_id;
+static void *hfp_ctl_monitor(void *arg);
+
+#define CTL_SOCKET_PATH "/etc/bluetooth/hfp_ctl_sk"
+#define HFP_EVENT_CONNECTION 1
+#define HFP_EVENT_CALL       2
+#define HFP_EVENT_CALLSETUP  3
+#define HFP_EVENT_VGS        4
+#define HFP_EVENT_VGM        5
+
+#define HFP_IND_DEVICE_DISCONNECTED 0
+#define HFP_IND_DEVICE_CONNECTED    1
+
+#define HFP_IND_CALL_NONE           0
+/* at least one call is in progress */
+#define HFP_IND_CALL_ACTIVE         1
+/* currently not in call set up */
+#define HFP_IND_CALLSETUP_NONE      0
+/* an incoming call process ongoing */
+#define HFP_IND_CALLSETUP_IN        1
+/* an outgoing call set up is ongoing */
+#define HFP_IND_CALLSETUP_OUT       2
+/* remote party being alerted in an outgoing call */
+#define HFP_IND_CALLSETUP_OUT_ALERT 3
+
+
+int hfp_ctl_init(void)
+{
+	if (pthread_create(&phfp_ctl_id, NULL, hfp_ctl_monitor, NULL)) {
+		perror("hfp_ctl_client");
+		teardown_socket_client(hfp_ctl_sk);
+		return -1;
+	}
+	pthread_setname_np(phfp_ctl_id, "hfp_ctl_monitor");
+
+	INFO("Server is ready for connection...\n");
+	return 0;
+}
+
+void hfp_ctl_delinit(void)
+{
+	/*set thread to cancel state, and free resouce
+	  thread will exit once teardown_socket_server()
+	  wakes thread up from recv()
+	 */
+	pthread_cancel(phfp_ctl_id);
+	pthread_detach(phfp_ctl_id);
+
+	hfp_connected = 0;
+	teardown_socket_client(hfp_ctl_sk);
+}
+
+int answer_call(void)
+{
+	unsigned int byte, ret = 1;
+	char msg[] = "A";
+	INFO("\n");
+	byte = send(hfp_ctl_sk, msg, strlen(msg), 0);
+
+	if (byte == strlen(msg))
+		ret = 0;
+
+	return ret;
+}
+
+int reject_call(void)
+{
+	unsigned int byte, ret = 1;
+	char msg[] = "+CHUP";
+	INFO("\n");
+	byte = send(hfp_ctl_sk, msg, strlen(msg), 0);
+	if (byte == strlen(msg))
+		ret = 0;
+
+	return ret;
+}
+
+int VGS_up(void)
+{
+	sVol += 1;
+	return set_VGS(sVol);
+}
+
+int VGS_down(void)
+{
+	sVol -= 1;
+	return set_VGS(sVol);
+
+}
+
+int VGM_up(void)
+{
+	mVol += 1;
+	return set_VGM(mVol);
+}
+
+int VGM_down(void)
+{
+	mVol -= 1;
+	return set_VGM(mVol);
+
+}
+
+int set_VGS(int value)
+{
+	unsigned int byte, ret = 1;
+	char msg[10] = {0};
+
+	//value range from 0 ~ 15
+	value = value < 0 ? 0 : value;
+	value = value > 15 ? 15 : value;
+
+	sprintf(msg, "+VGS=%d", value);
+	INFO("\n");
+	byte = send(hfp_ctl_sk, msg, strlen(msg), 0);
+	if (byte == strlen(msg))
+		ret = 0;
+
+	return ret;
+}
+
+int set_VGM(int value)
+{
+	unsigned int byte, ret = 1;
+	char msg[10] = {0};
+
+	//value range from 0 ~ 15
+	value = value < 0 ? 0 : value;
+	value = value > 15 ? 15 : value;
+
+	sprintf(msg, "+VGM=%d", value);
+	INFO("\n");
+	byte = send(hfp_ctl_sk, msg, strlen(msg), 0);
+	if (byte == strlen(msg))
+		ret = 0;
+
+	return ret;
+}
+
+static void *hfp_ctl_monitor(void *arg)
+{
+	int byte, value = -1, event =-1, i;
+	char msg[64];
+
+init:
+	hfp_ctl_sk = setup_socket_client(CTL_SOCKET_PATH);
+	if (hfp_ctl_sk < 0) {
+		sleep(3);
+		goto init;
+	}
+
+
+	INFO("recieving....\n");
+	while (1) {
+		memset(msg, 0, sizeof(msg));
+		byte = recv(hfp_ctl_sk, msg, sizeof(msg), 0);
+		if (byte < 0) {
+			perror("recv");
+			continue;
+		}
+		if (byte == 0) {
+			INFO("server off line\n");
+			teardown_socket_client(hfp_ctl_sk);
+			sleep(3);
+			goto init;
+		}
+
+		if (byte == 2) {
+			event = msg[0];
+			value = msg[1];
+			INFO("event = %d, value = %d\n", event, value);
+		} else {
+#if 0
+			INFO("invalid msg: %s\n", msg);
+			for (i = 0 ; i < byte; i++)
+				INFO("msg %d = %d\n", i, msg[i]);
+#endif
+			continue;
+		}
+
+		switch (event) {
+			case HFP_EVENT_CONNECTION:
+				switch (value) {
+					case HFP_IND_DEVICE_DISCONNECTED:
+						INFO("HFP disconnected!!!\n");
+						set_sco_enable(0);
+						hfp_connected = 0;
+						break;
+					case HFP_IND_DEVICE_CONNECTED:
+						INFO("HFP connected!!!\n");
+						hfp_connected = 1;
+						break;
+				}
+				break;
+
+			case HFP_EVENT_CALL:
+				switch (value) {
+					case HFP_IND_CALL_NONE:
+						INFO("Call stopped!!!\n");
+						set_sco_enable(0);
+						break;
+					case HFP_IND_CALL_ACTIVE :
+						INFO("Call active!!!\n");
+						set_sco_enable(1);
+						break;
+				}
+				break;
+
+			case HFP_EVENT_CALLSETUP:
+				switch (value) {
+					case HFP_IND_CALLSETUP_NONE:
+						INFO("Callsetup stopped!!!\n");
+						break;
+					case HFP_IND_CALLSETUP_IN :
+						INFO("An incomming Callsetup!!!\n");
+						break;
+					case HFP_IND_CALLSETUP_OUT :
+						INFO("An outgoing Callsetup!!!\n");
+						break;
+					case HFP_IND_CALLSETUP_OUT_ALERT :
+						INFO("Remote device being altered!!!\n");
+						break;
+				}
+				break;
+
+			case HFP_EVENT_VGS:
+				INFO("VGS EVENT!!!\n");
+				sVol = value;
+				break;
+			case HFP_EVENT_VGM:
+				INFO("VGM EVENT!!!\n");
+				mVol = value;
+				break;
+		}
+	}
+	INFO("exit\n");
+	return NULL;
+}
+
+static void signal_handler(int sig)
+{
+	INFO("INT/TERM signal detected\n");
+	hfp_ctl_delinit();
+	signal(sig, SIG_DFL);
+	exit(0);
+}
+
+
+int main(int argc, char **argv)
+{
+
+	if (hfp_ctl_init())
+		return -1;
+
+	signal(SIGINT, signal_handler);
+	signal(SIGTERM, signal_handler);
+	while (!hfp_connected)
+		sleep(1);
+
+#if 0
+	answer_call();
+	VGS_up();
+	VGM_up();
+	VGS_down();
+	VGM_down();
+	sleep(5);
+	reject_call();
+#endif
+	while (1)
+		sleep(1);
+
+}
diff --git a/utils/hfp_ctl.h b/utils/hfp_ctl.h
new file mode 100644
index 0000000..c2e3322
--- /dev/null
+++ b/utils/hfp_ctl.h
@@ -0,0 +1,13 @@
+#ifndef  _HFP_CTL_
+#define  _HFP_CTL_
+int hfp_ctl_init(void);
+void hfp_ctl_delinit(void);
+int answer_call(void);
+int reject_call(void);
+int VGS_up(void);
+int VGS_down(void);
+int VGM_up(void);
+int VGM_down(void);
+int set_VGS(int value);
+int set_VGM(int value);
+#endif
diff --git a/utils/sco_handler.c b/utils/sco_handler.c
new file mode 100644
index 0000000..44cb04e
--- /dev/null
+++ b/utils/sco_handler.c
@@ -0,0 +1,425 @@
+#include <errno.h>
+#include <poll.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/eventfd.h>
+#include "shared/log.h"
+#include <alsa/asoundlib.h>
+#include "sco_handler.h"
+#include <pthread.h>
+
+/****************************************/
+/*	Stream Direction:					*/
+/*	1. Income Stream: BT PCM -> SPEAKER	*/
+/*	2. Output Stream: MIC -> BT PCM		*/
+/****************************************/
+
+#define INFO(fmt, args...) \
+	printf("[SCO_HANDLER][%s] " fmt, __func__, ##args)
+
+//#define DEBUG_STREAM 1
+
+static pthread_t sco_rx_thread;
+static pthread_t sco_tx_thread;
+static int sco_enabled = 0;
+
+#define ALSA_DEVICE_CONF_PATH "/etc/alsa_bt.conf"
+#define DEVICE_SIZE 128
+static char pcm_device_mic[DEVICE_SIZE]	    = "hw:0,2";
+static char pcm_device_btpcm[DEVICE_SIZE]	= "hw:0,0";
+static char pcm_device_spk[DEVICE_SIZE]		= "dmixer_auto";
+static void get_alsa_device();
+static void *sco_rx_cb(void *arg);
+static void *sco_tx_cb(void *arg);
+
+#ifdef AVOID_UAC
+// Write a number to file path.
+bool write_value(const char* path, int enable)
+{
+	int fd = open(path, O_WRONLY);
+	if (fd < 0) {
+		printf("Open %s fail: %s.\n", path, strerror(errno));
+		return false;
+	}
+
+	char cmd[4];
+	int ret = snprintf(cmd, sizeof(cmd), "%d", enable);
+	if (ret <= 0)
+		printf("Convert num %d to string fail: %s.\n", enable, strerror(errno));
+	if (write(fd, cmd, strlen(cmd)) != strlen(cmd)) {
+		printf("Write %s to %d fail: %s.\n", cmd, fd, strerror(errno));
+	}
+	close(fd);
+	return true;
+}
+
+bool uac_audio_enable(int enable) {
+
+	int KpathLen = 50;
+	const char kuac_audio_enable[] = "/sys/devices/platform/audiobridge/bridge%d/enable";
+	char uac_audio_path[KpathLen];
+	if (snprintf(uac_audio_path, KpathLen, kuac_audio_enable, 0) != strlen(uac_audio_path)) {
+		printf("Set uac_audio_path path fail.\n");
+	}
+	if (!write_value(uac_audio_path,enable))
+		printf("Set uac_audio fail\n");
+
+	if (snprintf(uac_audio_path, KpathLen, kuac_audio_enable, 1) != strlen(uac_audio_path)) {
+		printf("Set uac_audio_path path fail.\n");
+	}
+	if (!write_value(uac_audio_path,enable))
+		printf("Set uac_audio fail\n");
+
+	return true;
+}
+#endif
+int set_sco_enable(int enable)
+{
+	INFO("%s sco stream\n", enable == 0 ? "Disable" : "Enable");
+	if (sco_enabled == enable) {
+		INFO("sco stream %s already\n", enable == 0 ? "disabled" : "enabled");
+		return 0;
+	}
+
+	sco_enabled = enable;
+	if (enable) {
+		get_alsa_device();
+#ifdef AVOID_UAC
+		INFO("disabling uac\n");
+		uac_audio_enable(0);
+#endif
+		if (pthread_create(&sco_rx_thread, NULL, sco_rx_cb, NULL)) {
+			INFO("rx thread create failed: %s\n", strerror(errno));
+			sco_enabled = 0;
+			return -1;
+		} else
+			pthread_setname_np(sco_rx_thread, "sco_rx_thread");
+
+		if (pthread_create(&sco_tx_thread, NULL, sco_tx_cb, NULL)) {
+			INFO("tx thread create failed: %s\n", strerror(errno));
+			sco_enabled = 0;
+			return -1;
+		} else
+			pthread_setname_np(sco_tx_thread, "sco_tx_thread");
+
+	} else {
+		if (sco_rx_thread) {
+			pthread_detach(sco_rx_thread);
+			sco_rx_thread  = 0;
+		}
+		if (sco_tx_thread) {
+			pthread_detach(sco_tx_thread);
+			sco_tx_thread  = 0;
+		}
+	}
+
+	return 0;
+
+}
+
+static void get_alsa_device()
+{
+	FILE *stream;
+	char *line = NULL;
+	size_t len = 0;
+	ssize_t read;
+	int i;
+
+	/* conf format:
+		spk=dimxer_avs_auto
+		mic=hw:0,2
+		pcm=hw:0,0
+	*/
+
+	stream = fopen(ALSA_DEVICE_CONF_PATH, "r");
+	if (stream == NULL) {
+		INFO("open ALSA DEVICE CONF error, use default\n");
+		char temp[64] = "spk=dimxer_avs_auto\nmic=hw:0,2\npcm=hw:0,0\n";
+		INFO("If soundcard devcie changed, set them at %s like:\n%s", ALSA_DEVICE_CONF_PATH, temp);
+		return;
+	}
+
+	while ((read = getline(&line, &len, stream)) != -1) {
+		INFO("Retrieved line of length %zu :\n", read);
+		INFO("%s\n", line);
+		/* remove the newline char */
+		line[read - 1] = 0;
+		if (strstr(line, "spk")) {
+			memset(pcm_device_spk, 0, DEVICE_SIZE);
+			strncpy(pcm_device_spk, line + 4, DEVICE_SIZE - 1);
+			for (i = 0; i < 48; i++)
+				printf("%x ", pcm_device_spk[i]);
+			printf("\n");
+		} else if (strstr(line, "mic")) {
+			memset(pcm_device_mic, 0, DEVICE_SIZE);
+			strncpy(pcm_device_mic, line + 4, DEVICE_SIZE - 1);
+		} else if (strstr(line, "pcm")) {
+			memset(pcm_device_btpcm, 0, DEVICE_SIZE) ;
+			strncpy(pcm_device_btpcm, line + 4, DEVICE_SIZE - 1);
+		}
+	}
+
+	free(line);
+	fclose(stream);
+
+}
+
+static void *sco_rx_cb(void *arg)
+{
+	snd_pcm_t *pcm_handle_capture;
+	snd_pcm_t *pcm_handle_playback;
+	snd_pcm_hw_params_t *snd_params;
+	snd_pcm_format_t format = SND_PCM_FORMAT_S16_LE;
+	const int channels = 1, expected_frames = 60;
+	int dir, status, buf_size, rate = 8000;
+	char *buf;
+	snd_pcm_uframes_t frames = 120;
+
+	INFO("setting bt pcm\n");
+	/*********BT PCM ALSA SETTING****************************/
+	status = snd_pcm_open(&pcm_handle_capture, pcm_device_btpcm,
+						  SND_PCM_STREAM_CAPTURE,	/*bt pcm as input device*/
+						  0);		 				/*ASYNC MODE*/
+
+
+	if (status < 0) {
+		INFO("bt pcm open fail:%s\n", strerror(errno));
+		return NULL;
+	}
+#if 0
+	status = snd_pcm_set_params(pcm_handle_capture, SND_PCM_FORMAT_S16_LE,
+								SND_PCM_ACCESS_RW_INTERLEAVED,
+								1,				/*1 channel*/
+								8000,			/*8k sample rete*/
+								0,				/*allow alsa resample*/
+								100000);		/*max latence = 100ms*/
+#endif
+	snd_pcm_hw_params_alloca(&snd_params);
+	snd_pcm_hw_params_any(pcm_handle_capture, snd_params);
+	snd_pcm_hw_params_set_access(pcm_handle_capture, snd_params,
+								 SND_PCM_ACCESS_RW_INTERLEAVED);
+	snd_pcm_hw_params_set_format(pcm_handle_capture, snd_params, format);
+	snd_pcm_hw_params_set_channels(pcm_handle_capture, snd_params, channels);
+	snd_pcm_hw_params_set_rate_near(pcm_handle_capture, snd_params, &rate, 0);
+	snd_pcm_hw_params_set_period_size_near(pcm_handle_capture, snd_params, &frames, &dir);
+
+
+	status = snd_pcm_hw_params(pcm_handle_capture, snd_params);
+
+	if (status < 0) {
+		INFO("bt pcm set params fail:%s\n", strerror(errno));
+		snd_pcm_close(pcm_handle_capture);
+		return NULL;
+	}
+
+	INFO("setting speaker\n");
+	/*********SPEAKER ALSA SETTING****************************/
+	status = snd_pcm_open(&pcm_handle_playback, pcm_device_spk,
+						  SND_PCM_STREAM_PLAYBACK,	/*speaker as output device*/
+						  1);						/*NOBLOCK MODE*/
+	if (status < 0) {
+		INFO("speaker open fail:%s\n", strerror(errno));
+		return NULL;
+	}
+
+	status = snd_pcm_set_params(pcm_handle_playback, SND_PCM_FORMAT_S16_LE,
+								SND_PCM_ACCESS_RW_INTERLEAVED,
+								1,				/*1 channel*/
+								8000,			/*8k sample rete*/
+								1,				/*allow alsa resample*/
+								500000);		/*expected max latence = 500ms*/
+
+	if (status < 0) {
+		INFO("bt pcm set params fail:%s\n", strerror(errno));
+		snd_pcm_close(pcm_handle_capture);
+		snd_pcm_close(pcm_handle_playback);
+		return NULL;
+	}
+
+#ifdef DEBUG_STREAM
+	FILE *fp;
+	fp = fopen("/tmp/rx_cb.wav", "w+");
+	if (fp  == NULL)
+		INFO("create wav file error");
+#endif
+
+	INFO("start streaming\n");
+	/*********STREAM HANDLING BEGIN***************************/
+	buf_size = expected_frames * 1 * 2;	/*bytes = frames * ch * 16Bit/8 */
+	buf = malloc(buf_size);
+	frames = 0;
+	while (sco_enabled) {
+		memset(buf, 0, buf_size);
+		frames = snd_pcm_readi(pcm_handle_capture, buf, expected_frames);
+		if (frames == -EPIPE) {
+			INFO("pcm read underrun\n");
+			snd_pcm_prepare(pcm_handle_capture);
+			frames = 0;
+			continue;
+		} else if (frames == -EBADFD) {
+			INFO("pcm read EBADFD, retring\n");
+			frames = 0;
+			continue;
+		}
+
+#ifdef DEBUG_STREAM
+		if (fp)
+			fwrite(buf, frames * 2, 1, fp);
+#endif
+
+		frames = snd_pcm_writei(pcm_handle_playback, buf, frames);
+		/*if write failed somehow, just ignore, we don't want to wast too much time*/
+		if (frames == -EPIPE) {
+			INFO("speaker write underrun\n");
+			snd_pcm_prepare(pcm_handle_playback);
+		} else if (frames == -EBADFD) {
+			INFO("speaker write  EBADFD\n");
+		}
+	}
+	INFO("stopping\n");
+	/********STOP**********************************************/
+	snd_pcm_close(pcm_handle_capture);
+	snd_pcm_close(pcm_handle_playback);
+	free(buf);
+#ifdef DEBUG_STREAM
+	fclose(fp);
+#endif
+#ifdef AVOID_UAC
+	INFO("disbling uac\n");
+	uac_audio_enable(1);
+#endif
+	return NULL;
+}
+
+
+static void *sco_tx_cb(void *arg)
+{
+	snd_pcm_t *pcm_handle_capture;
+	snd_pcm_t *pcm_handle_playback;
+	snd_pcm_hw_params_t *snd_params;
+	snd_pcm_format_t format = SND_PCM_FORMAT_S16_LE;
+	const int mic_channels = 1, expected_frames = 60;
+	int dir, status, buf_size, i, rate = 8000;
+	char *buf;
+	snd_pcm_uframes_t frames = 120;
+
+	INFO("setting mic\n");
+	/********MIC ALSA SETTING****************************/
+	status = snd_pcm_open(&pcm_handle_capture, pcm_device_mic,
+						  SND_PCM_STREAM_CAPTURE,	/*mic as input device*/
+						  0);						/*ASYNC MODE*/
+
+
+	if (status < 0) {
+		INFO("mic open fail:%s\n", strerror(errno));
+		return NULL;
+	}
+#if 0
+	status = snd_pcm_set_params(pcm_handle_capture, SND_PCM_FORMAT_S16_LE,
+								SND_PCM_ACCESS_RW_INTERLEAVED,
+								1,				/*1 channel*/
+								8000,			/*8k sample rete*/
+								0,				/*allow alsa resample*/
+								100000);		/*max latence = 100ms*/
+#else
+	snd_pcm_hw_params_alloca(&snd_params);
+	snd_pcm_hw_params_any(pcm_handle_capture, snd_params);
+	snd_pcm_hw_params_set_access(pcm_handle_capture, snd_params,
+								 SND_PCM_ACCESS_RW_INTERLEAVED);
+	snd_pcm_hw_params_set_format(pcm_handle_capture, snd_params, format);
+	snd_pcm_hw_params_set_channels(pcm_handle_capture, snd_params, mic_channels);
+	snd_pcm_hw_params_set_rate_near(pcm_handle_capture, snd_params, &rate, 0);
+	snd_pcm_hw_params_set_period_size_near(pcm_handle_capture, snd_params, &frames, &dir);
+
+
+	status = snd_pcm_hw_params(pcm_handle_capture, snd_params);
+#endif
+
+	if (status < 0) {
+		INFO("mic set params fail:%s\n", strerror(errno));
+		snd_pcm_close(pcm_handle_capture);
+		return NULL;
+	}
+
+	INFO("setting bt pcm\n");
+	/*********BT PCM ALSA SETTING****************************/
+	status = snd_pcm_open(&pcm_handle_playback, pcm_device_btpcm,
+						  SND_PCM_STREAM_PLAYBACK,	/*bt pcm as output device*/
+						  1);						/*NOBLOCK MODE*/
+	if (status < 0) {
+		INFO("bt pcm open fail:%s\n", strerror(errno));
+		return NULL;
+	}
+
+	status = snd_pcm_set_params(pcm_handle_playback, SND_PCM_FORMAT_S16_LE,
+								SND_PCM_ACCESS_RW_INTERLEAVED,
+								1,				/*1 channel*/
+								8000,			/*8k sample rete*/
+								1,				/*allow alsa resample*/
+								500000);		/*expected max latence = 500ms*/
+
+	if (status < 0) {
+		INFO("bt pcm set params fail:%s\n", strerror(errno));
+		snd_pcm_close(pcm_handle_capture);
+		snd_pcm_close(pcm_handle_playback);
+		return NULL;
+	}
+
+#ifdef DEBUG_STREAM
+	FILE *fp;
+	fp = fopen("/tmp/tx_cb.wav", "w+");
+	if (fp  == NULL)
+		INFO("create wav file error");
+#endif
+
+	INFO("start streaming\n");
+	/*********STREAM HANDLING BEGIN***************************/
+	buf_size  = expected_frames * mic_channels * 2;	/*bytes = frames * ch * 16Bit/8 */
+	buf  = malloc(buf_size);
+
+	while (sco_enabled) {
+
+		memset(buf, 0, buf_size);
+
+		frames = snd_pcm_readi(pcm_handle_capture, buf, expected_frames);
+		if (frames == -EPIPE) {
+			INFO("mic read underrun\n");
+			snd_pcm_prepare(pcm_handle_capture);
+			frames = 0;
+			continue;
+		} else if (frames == -EBADFD) {
+			INFO("mic read EBADFD, retring\n");
+			frames = 0;
+			continue;
+		}
+
+#ifdef DEBUG_STREAM
+		if (fp)
+			fwrite(buf, frames * 2, 1, fp);
+#endif
+
+		frames = snd_pcm_writei(pcm_handle_playback, buf, frames);
+		/*if write failed somehow, just ignore, we don't want to wast too much time*/
+		if (frames == -EPIPE) {
+			INFO("bt pcm write underrun\n");
+			snd_pcm_prepare(pcm_handle_playback);
+		} else if (frames == -EBADFD) {
+			INFO("bt pcm write  EBADFD\n");
+		}
+	}
+	INFO("stopping\n");
+	/********STOP**********************************************/
+	snd_pcm_close(pcm_handle_capture);
+	snd_pcm_close(pcm_handle_playback);
+	free(buf);
+#ifdef DEBUG_STREAM
+	fclose(fp);
+#endif
+#ifdef AVOID_UAC
+	INFO("disbling uac\n");
+	uac_audio_enable(1);
+#endif
+	return NULL;
+}
+
diff --git a/utils/sco_handler.h b/utils/sco_handler.h
new file mode 100644
index 0000000..9d54638
--- /dev/null
+++ b/utils/sco_handler.h
@@ -0,0 +1,4 @@
+#ifndef SCO_HANDLER_H
+#define SCO_HANDLER_H
+int set_sco_enable(int enable);
+#endif
-- 
2.25.1

