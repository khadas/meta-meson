Index: git/fscryptctl.c
===================================================================
--- git.orig/fscryptctl.c
+++ git/fscryptctl.c
@@ -297,6 +297,22 @@ static ssize_t read_until_limit_or_eof(i
   return pos;
 }
 
+static int32_t read_keyid(uint32_t *key_id) {
+	int32_t ret = -1;
+	if (!key_id) {
+		goto error;
+	}
+	if (scanf("%u", key_id) == EOF) {
+		fprintf(stderr, "error: read_keyid failed: %s\n",
+				strerror(errno));
+	} else {
+		//printf("key_id read is %u\n", *key_id);
+		ret = 0;
+	}
+error:
+	return ret;
+}
+
 // Reads a raw key, of size at least FSCRYPT_MIN_KEY_SIZE bytes and at most
 // FSCRYPT_MAX_KEY_SIZE bytes, from standard input into the provided buffer.
 // On success, returns the key size in bytes.  On failure, returns 0.
@@ -372,6 +388,50 @@ static bool set_policy(const char *path,
 //                                 Commands
 // -----------------------------------------------------------------------------
 
+static int cmd_add_key_by_keyid(int argc, char *const argv[]) {
+  handle_no_options(&argc, &argv);
+  if (argc != 1) {
+    fputs("error: must specify a single mountpoint\n", stderr);
+    return EXIT_FAILURE;
+  }
+  const char *mountpoint = argv[0];
+
+  struct fscrypt_add_key_arg *arg =
+      calloc(sizeof(*arg) + FSCRYPT_MAX_KEY_SIZE, 1);
+  if (!arg) {
+    fputs("error: failed to allocate memory\n", stderr);
+    return EXIT_FAILURE;
+  }
+
+  int status = EXIT_FAILURE;
+  if (read_keyid(&arg->key_id) < 0) {
+    goto cleanup;
+  }
+  arg->key_spec.type = FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER;
+
+  int fd = open(mountpoint, O_RDONLY | O_CLOEXEC);
+  if (fd < 0) {
+    fprintf(stderr, "error: opening %s: %s\n", mountpoint, strerror(errno));
+    goto cleanup;
+  }
+  if (ioctl(fd, FS_IOC_ADD_ENCRYPTION_KEY, arg) != 0) {
+    fprintf(stderr, "error: adding key to %s: %s\n", mountpoint,
+            describe_fscrypt_v2_error(errno));
+    close(fd);
+    goto cleanup;
+  }
+  close(fd);
+
+  char identifier_hex[FSCRYPT_KEY_IDENTIFIER_HEX_SIZE];
+  bytes_to_hex(arg->key_spec.u.identifier, FSCRYPT_KEY_IDENTIFIER_SIZE,
+               identifier_hex);
+  puts(identifier_hex);
+  status = EXIT_SUCCESS;
+cleanup:
+  free(arg);
+  return status;
+}
+
 static int cmd_add_key(int argc, char *const argv[]) {
   handle_no_options(&argc, &argv);
   if (argc != 1) {
@@ -706,7 +766,7 @@ static const struct {
 } commands[] = {
     {"add_key", cmd_add_key},       {"remove_key", cmd_remove_key},
     {"key_status", cmd_key_status}, {"get_policy", cmd_get_policy},
-    {"set_policy", cmd_set_policy},
+    {"set_policy", cmd_set_policy}, {"add_key_by_keyid", cmd_add_key_by_keyid},
 };
 
 int main(int argc, char *const argv[]) {
